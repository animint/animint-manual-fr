---
title: Grammaire graphique
layout: default
output: bookdown::html_chapter
---

# Chapitre 2, visualisation de données à l'aide de la grammaire graphique {#chapter-2}

```{r setup, echo=FALSE}
knitr::opts_chunk$set(fig.path="Ch02-figures/")
```

Ce chapitre explique la grammaire graphique, qui est un puissant outilpour décrire une grande classe de visualisations de données.
Après avoir lu ce chapitre, vous serez en mesure de

- citer les avantages de la grammaire graphique par rapport aux méthodes précédentes
- Installer le paquet R animint2
- Traduire les esquisses de tracé en code ggplot dans R
- Afficher des ggplots sur des pages web en utilisant animint2
- Créer des ggplots multicouches
- Créer des ggplots multi-panneaux

## Histoire et objectif de la grammaire graphique {#history}

La plupart des systèmes informatiques d'analyse de données proposent des fonctions de création de
graphiques pour visualiser les schémas des données. Les systèmes les plus anciens fournissent des
fonctions très générales permettant de dessiner les éléments de base d'un graphique, tels que les lignes et les 
points (par exemple, les paquets `graphics` et `grid` dans R).
Si vous utilisez un de ces systèmes généraux, c'est à vous de mettre les composants en place pour former un graphique significatif et interprétable. L'avantage de
L'avantage des systèmes généraux est qu'ils n'imposent que peu de limites sur les types de tracés qui peuvent être créés.
L'inconvénient est que les systèmes généraux ne fournissent généralement pas de fonctions permettant d'automatiser les tâches les plus courantes (axes, panneaux, légendes).

Pour pallier les inconvénients de ces systèmes de traçage généraux,
des paquets tels que `lattice` ont été développés ([Sarkar, 2008](http://lmdvr.r-forge.r-project.org/figures/figures.html)).
De tels paquets disposent de plusieurs types de graphiques prédéfinis et fournissent une interface dédiée pour créer chaque type de graphique.
Par exemple, `lattice` fournit la fonction `bwplot` permettant de réaliser des diagrammes en boîte et des diagrammes à moustaches.
L'avantage de ces systèmes est qu'ils facilitent grandement la création de graphiques complets, y compris une légende et des panneaux.
L'inconvénient est l'ensemble des types de graphiques prédéfinis, ce qui signifie qu'il n'est pas facile de créer des graphiques plus complexes.

Les nouveaux systèmes de traçage basés sur la grammaire des graphiques sont situés/se situent entre ces deux extrêmes.
Wilkinson a proposé la grammaire graphique afin de décrire et de créer une grande classe de tracés ([Wilkinson, 2005](http://www.springer.com/us/book/9780387245447?wt_mc=GoogleBooks.GoogleBooks.3.EN&token=gbgen#otherversion=9780387286952)).
Wickham a par la suite implémenté plusieurs idées de la grammaire graphique dans le paquet `ggplot2` ([Wickham, 2009](https://www.amazon.com/dp/0387981403/ref=cm_sw_su_dp?tag=ggplot2-20)).
Le paquet `ggplot2` présente plusieurs avantages par rapport aux systèmes de traçage antérieurs.

- Comme les systèmes de traçage généraux, et contrairement aux `lattice`, `ggplot2`
  impose peu de limites aux types de tracés qui peuvent être créés
  (il n'y a pas de types de graphiques prédéfinis).
- Contrairement aux systèmes de traçage généraux, et comme `lattice`, `ggplot2`
  facilite l'inclusion d'éléments de tracé communs tels que les axes, les panneaux et les
  légendes.
- Etant donné que `ggplot2` est basé sur la grammaire des graphiques, un mappage
  explicite des variables de données aux propriétés visuelles est nécessaire. Plus loin dans ce
  chapitre, nous expliquerons comment ce mappage permet de traduire directement en code R des brouillons de grpahiques.

Enfin, tous les systèmes de traçage évoqués précédemment sont destinés à être utilisés pour créer des graphiques *statiques*,
qui peuvent tout aussi bien être visualisés sur un écran d'ordinateur ou sur papier.
Cependant, le sujet principal de ce manuel est `animint2`, un paquet R pour des graphiques *interactifs*.
Contrairement à des grapqhiues statiques, les graphiques interactifs sont à visualiser de préference sur un ordinateur.
avec une souris et un clavier qui peuvent être utilisés pour interagir avec le tracé.

Étant donné que de nombreux concepts issus des graphiques statiques sont également utiles pour les
graphiques interactifs, le paquet `animint2` est implémenté sous la forme d'une extension/fork de `ggplot2`.
Dans ce chapitre, nous présenterons les principales caractéristiques de `ggplot2` qui seront également utiles pour les tracés interactifs
dans les chapitres suivants.

En 2013, nous avons créé le paquet animint, qui dépend du paquet ggplot2.
Cependant, au cours de la période 2014-2017, le package ggplot2 a introduit de nombreux 
changements qui étaient incompatibles avec la grammaire interactive de
animint. Par conséquent, en 2018, nous avons créé le paquet animint2 qui
copie/fork les parties nécessaires du paquet ggplot2. Maintenant animint2
peut être utilisé sans que ggplot2 soit installé. En fait, c'est
recommandé d'utiliser animint2 sans attacher (via la bibliothèque)
ggplot2. Cependant, il est possible d'utiliser animint2 avec des paquets qui
importent/chargent ggplot2. Pour un exemple, voir
[Chapitre 16](Ch16-change-point.html) qui utilise le paquet penaltyLearning
(qui importe ggplot2).




## Installer et attacher animint2 {#installing}

Pour installer la version la plus récente de `animint2` à partir du CRAN,

```{r installCRAN}
if(!requireNamespace("animint2"))install.packages("animint2")
```

Pour installer une version de développement encore plus récente de `animint2` depuis GitHub,

```{r installGitHub}
if(!requireNamespace("animint2")){
  if(!requireNamespace("remotes"))install.packages("remotes")
  remotes::install_github("tdhock/animint2")
}
```

Une fois que vous avez installé animint2, vous pouvez charger et attacher toutes ses
fonctions exportées avec :

```{r attach}
library(animint2)
```

## Traduire les esquisses de tracés en ggplots {#sketching}

Cette section explique comment traduire une esquisse de tracé en
en code R. Nous utilisons un ensemble de données de la World Bank comme exemple,
et nous commençons par charger et examiner un sous-ensemble de ces données.

```{r data}
data(WorldBank, package="animint2")
WorldBank$Region <- sub(" (all income levels)", "", WorldBank$region, fixed=TRUE)
head(WorldBank)
tail(WorldBank)
dim(WorldBank)
```

Les données `WorldBank` consistent en des mesures telles que le taux de fécondité
et l'espérance de vie pour chaque pays sur la période 1960-2010. Les commandes
ci-dessus impriment les premières et les dernières lignes, ainsi que la dimension de l'ensemble des données,
pour le sous-ensemble des 5 dernières années (`r nrow(WorldBank)` lignes et `r ncol(WorldBank)` colonnes).

Supposons que nous cherchions à déterminer s'il existe une relation entre l'espérance
de vie et le taux de fécondité. Nous pourrions fixer une année,
puis utiliser ces deux variables dans un nuage de points. Considérons la
figure ci-dessous qui esquisse les principales composantes de cette visualisation de données.

![Diagramme de dispersion de la Banque mondiale](Ch02-viz-scatter.png)

Le croquis ci-dessus montre l'espérance de vie sur l'axe horizontal (x),
le taux de fécondité sur l'axe vertical (y), et une légende pour la région.
Ces éléments du croquis peuvent être directement traduits en R en utilisant la méthode suivante.
Tout d'abord, nous devons construire un fichier de données qui comporte une ligne pour chaque pays
en 1975, et des colonnes nommées `esperance.vie`, `taux.fertilité`, et `region`. Les `WorldBank`
possèdent déjà ces colonnes, il suffit donc de prendre en compte les données pour l'année 1975 :

```{r head}
WorldBank1975 <- subset(WorldBank, year==1975)
head(WorldBank1975)
```

Le code ci-dessus imprime les données de l'année 1975, qui comportent clairement les
colonnes appropriées et une ligne pour chaque pays. L'étape suivante consiste à
utiliser les notes du croquis pour coder un ggplot avec un mappage esthétique (`aes`) correspondant
des variables de données avec les propriétés visuelles :

```{r scatter}
scatter <- ggplot()+
  geom_point(
    mapping=aes(x=life.expectancy, y=fertility.rate, color=Region),
    data=WorldBank1975)+
    xlab("Espérance de vie") + ylab("Taux de fertilité")+
    scale_color_discrete(name = "Régions",labels=c("Asie de l'Est & Pacifique", "Europe & Asie Centrale", "Amérique Latine & Caraïbes", "Moyen Orient & Afrique du Nord", "Amérique du Nord", "Asie du Sud", "Afrique Sub-Saharienne"))

scatter
```

La fonction `aes` est appelée avec les noms des propriétés visuelles (`x`,
`y`, `color`) et les valeurs des variables de données correspondantes
(`esperance.vie`, `taux.fertilité`, `region`). Ce mappage est
appliquée aux variables dans le tableau de données `WorldBank1975`, afin
de créer les propriétés visuelles du tracé `geom_point`. Le ggplot a été
sauvegardé en tant que `scatter` qui, lorsqu'il est imprimé avec la commande R
affiche le tracé sur un périphérique graphique. Notez que nous avons automatiquement
une légende en couleur pour les `region`.

## Afficher des ggplots sur des pages web en utilisant animint {#rendering-with-animint}

Cette section explique comment l'outil `animint2` peut être utilisé pour afficher des ggplots sur des pages web.
Le ggplot de la section précédente peut être affiché avec animint2, en utilisant la fonction `animint`.

```{r Ch02-scatter}
animint(scatter)
```

Si, lorsque vous exécutez le code ci-dessus, l'animint ne s'affiche pas dans votre site web
pour une raison quelconque (par exemple, si vous voyez une page web vierge), alors
veuillez consulter notre [wiki FAQ](https://github.com/tdhock/animint2/wiki/FAQ#web-browser-on-local-indexhtml-file-is-blank)
qui vous aidera à trouver une solution.
En interne, la fonction `animint` crée une liste de classe animint, puis R exécute la fonction `print.animint` via la fonction [objet S3
system](http://adv-r.had.co.nz/OO-essentials.html#s3). Le paquet `animint2` met en œuvre un compilateur qui prend la liste en entrée, et
produit une page web avec une visualisation de données.
Le compilateur est la fonction `animint2dir` qui compile la liste animint `scatter.viz` en un répertoire de fichiers de données et de code qui
peuvent être utilisés par les utilisateurs dans un navigateur web.
Il est activé automatiquement par la fonction `print.animint`.

Lorsqu'il est visualisé dans un navigateur web, le tracé animint doit ressembler aux versions statiques produites par les périphériques graphiques R standard.
Une différence est que la légende de la région est interactive : cliquer sur une légende permet de masquer ou afficher les points de cette couleur.

**Exercice**: essayez de modifier la valeur de l'élément `aes` mapping du ggplot, et ensuite de créer une nouvelle animint.
Les variables quantitatives comme `population` sont mieux représentées à l'aide des axes `x`/`y` ou points `size`.
Les variables qualitatives comme `lending` sont mieux représentées à l'aide de points `color` ou `fill`.

## Visualisation de données multicouches (plusieurs régions) {#multi-layer}

La visualisation de données multicouches est utile lorsque vous souhaitez afficher
plusieurs régions ou ensembles de données différents dans le même graphique. Par exemple,
considérez le croquis suivant qui ajoute un `geom_path` à la visualisation de données précedente.

![Visualisation multicouche des données de la Banque mondiale](Ch02-two-layer-viz.png)

Notez que le croquis ci-dessus inclut deux geoms différents (point et chemin).
Les deux geoms partagent une définition commune de la fonction `x`, `y`, et de l'esthétique `color`, mais ont des ensembles de données différents.
Nous traduisons ci-dessous cette croquis en code R.

```{r Ch02-two-layer-viz}
WorldBankBefore1975 <- subset(WorldBank, 1970 <= year & year <= 1975)
two.layers <- scatter+
  geom_path(aes(
    x=life.expectancy, 
    y=fertility.rate, 
    color=Region,
    group=country),
    data=WorldBankBefore1975)
(viz.two.layers <- animint(two.layers))
```

Notez que nous sauvegardons la valeur de retour de la fonction `animint` dans l'objet `viz.two.layers` (qui est également imprimée grâce aux parenthèses).
Dans ce manuel, nous utiliserons souvent des noms de variables qui commencent par `viz` pour désigner les objets de visualisation de données animint, qui
sont en fait des listes de ggplots et d'options.

Le graphique ci-dessus montre une visualisation de données avec 2 geoms/couches :

- le `geom_point` montre l'espérance de vie, le taux de fécondité et les régions de tous les pays en 1975.
- Les `geom_path` montre les mêmes variables pour les 5 années précédentes.

L'ajout de la `geom_path` montre comment les pays ont changé au fil du temps. Elle montre notamment que la plupart des pays se sont déplacés vers la droite
et vers le bas, ce qui signifie une augmentation de l'espérance de vie et une baisse de la fécondité.
Il y a toutefois quelques exceptions. Par exemple, les deux pays d'Asie de l'Est en bas à gauche ont vu une diminution du taux de vie au cours de cette période.
Certains pays montrent une augmentation du taux de fécondité.

**Exercice**: essayez de modifier la valeur de l'élément `region` en une légende `income` légende.
Conseil : vous devez utiliser le même `aes(color=income)` pour tous les géoms.
Vous pouvez utiliser `scale_color_manual` avec une palette de couleurs séquentielle, voir
`RColorBrewer::display.brewer.all(type="seq")` et
[lire l'annexe pour plus d'informations
détails](Ch99-appendix.html#manual-color-legends).

Pouvons-nous ajouter les noms des pays à l'image de données ? Ci-dessous, nous ajoutons un autre calque avec une étiquette de texte pour le nom de chaque pays.

```{r Ch02-three-layer-viz}
three.layers <- two.layers+
  geom_text(aes(
    x=life.expectancy, 
    y=fertility.rate, 
    color=Region,
    label=country),
    data=WorldBank1975)
animint(three.layers)
```

Cette image de données n'est pas facile à lire, car il y a beaucoup d'étiquettes de texte qui se chevauchent.
La légende interactive des région aide un peu, en permettant à l'utilisateur de masquer les données des régions sélectionnées.
Cependant, ce serait encore mieux si l'utilisateur pouvait afficher et masquer le texte pour chaque pays.
Ce type d'interaction peut être réalisé en utilisant les esthétiques showSelected et clickSelects que nous expliquons dans les chapitres 3 et 4.

Pour l'instant, nous allons discuter d'un atout majeur d'animint : la visualisation de données avec de multiples tracés liés.

## Visualisation de données multiplot {#multi-plot}

La visualisation de données en multiplot est utile lorsque vous souhaitez montrer des ensembles de données liés en utilisant plus d'une esthétique de cartographie.
En visualisation de données interactive, un graphe est souvent utilisé pour afficher un résumé et un autre pour afficher les détails.
Par exemple, considérons une visualisation de données avec deux tracés : une série temporelle avec les données de la Banque mondiale de 1960 à 2010 (résumé),
et un nuage de points avec les données de la Banque mondiale de 1975 (détails). Nous esquissons ci-dessous le tracé de la série temporelle.

![Vue des données de la Banque mondiale avec deux graphiques](Ch02-viz-two-plots.png)

Notez que le croquis ci-dessus peut être directement traduit en code R ci-dessous.
Pour plus de simplicité, nous commençons par réduire l'échantillon de données à tous les cinq ans (certains navigateurs web comme Chrome ne sont pas en mesure d'afficher plus de 10 000 points de données en une seule fois),

```{r}
WorldBankSome <- subset(WorldBank, year %% 5 == 0)
dim(WorldBankSome)
table(WorldBankSome$year)
```

Le tableau ci-dessus montre qu'il y a 214 lignes pour chacune des années de l'ensemble de données.
Ensuite, nous copions la liste existante de viz (`viz.two.layers`),
puis nous assignons un ggplot à un nouvel élément nommé `timeSeries`.

```{r vizTwoPlots}
viz.two.plots <- viz.two.layers
viz.two.plots$timeSeries <- ggplot()+
  geom_line(aes(
    x=year, 
    y=fertility.rate, 
    color=Region, 
    group=country),
    data=WorldBankSome)
```

Il en résulte une liste nommée de deux éléments (les deux éléments sont des
ggplots avec la classe `gganimint`).

```{r summaryTwo}
summary(viz.two.plots)
```

Cette liste de visualisation de données peut être imprimée/affichée en tapant son nom.
Comme la liste contient deux ggplots, `animint2`affiche la vue des données sous forme de deux graphiques liés.

```{r Ch02-viz-two-plots}
viz.two.plots
```

La visualisation de données ci-dessus contient deux ggplots, qui cartographient chacun différentes variables de données sur l'axe horizontal `x`.
La série temporelle utilise `aes(x=year)` et présente un résumé des valeurs du taux de fécondité sur toutes les années.
Le nuage de points utilise `aes(x=life.expectancy)` et montre les détails de la relation entre le taux de fécondité et l'espérance de vie
au cours de l'année 1975.

**Essayez** de cliquer sur une entrée de la légende dans le nuage de points ou dans le diagramme de temps ci-dessus.
Vous devriez voir les données et les légendes mises à jour dans les deux diagrammes simultanément.
Puisque l'esthétique `aes(color=Region)` a été spécifiée dans les deux graphiques,
animint crée une seule variable de sélection partagée appelée `Region`.
Le fait de cliquer sur l'une ou l'autre des légendes a pour effet de mettre à jour l'ensemble de
régions sélectionnées, et donc animint met à jour les légendes et les données dans les deux régions en conséquence.
C'est le principal mécanisme utilisé par animint pour pour créer des visualisations de données interactives avec des graphiques liés,
qui sera vu plus en détail dans les deux prochains chapitres.

**Exercice**: utilisez animint pour créer un data viz avec trois graphes, en créant une liste avec trois ggplots.
Par exemple, vous pouvez ajouter une série temporelle d'une autre variable de données telle que `life.expectancy` ou
`population`.

Notez que les deux ggplots font correspondre la variable du taux de fécondité à l'axe y.
Cependant, étant donné qu'il s'agit de graphiques distincts, les étendues de leurs axes y sont calculées séparément.
Cela signifie que même si les deux tracés sont affichés côte à côte, les deux axes des ordonnées ne sont pas exactement alignés.
C'est un problème, car cela faciliterait le décodage de la visualisation des données si chaque unité d'espace vertical était utilisée
pour montrer la même quantité de taux de fécondité.
Pour obtenir cet effet, nous utilisons des facettes dans la section suivante.

## Visualisation de données multi-panneaux (facettes) {#multi-panel}

Les panneaux ou facettes sont des sous-plans qui présentent des données de visualisation reliées.
L'une des principales forces de ggplots réside dans le fait que différents types de graphiques multi-panneaux sont relativement faciles à créer.
Les graphiques multi-panneaux sont utiles pour deux raisons différentes :

- Vous souhaitez aligner les axes de plusieurs tracés connexes contenant des geoms différents. Cela facilite la comparaison entre plusieurs
  géoms différents, et c'est une technique qui est aussi utile pour la visualisation de données interactive.
- Vous souhaitez diviser les données d'un géom en plusieurs panneaux. Cela facilite la comparaison entre les sous-ensembles de données, et est moins utile pour
  la visualisation de données interactive (l'interactivité peut souvent être utilisée pour obtenir le même effet de comparaison de sous-ensembles de données).

### Différents géomes dans chaque panneau (axes alignés) {#aligned-axes}

Nous commençons par expliquer comment les facettes sont utiles pour aligner les axes de
des tracés apparentés. Considérons le croquis ci-dessous qui contient un tracé avec
deux panneaux.

![Tracé aligné de la Banque mondiale](Ch02-viz-aligned.png)

Notez que les deux panels tracent des géomes différents à l'aide d'une esthétique propre à chaque panneau.
Le point et le chemin dans le panneau de gauche ont `x=life.expectancy` et la ligne du panneau de droite a `x=year`.
Notez également que nous avons spécifié `facet=x.var` nous devons donc ajouter une variable appelée `x.var` à chacun des trois ensembles de données.
Nous traduisons cette esquisse au code R ci-dessous.

```{r Ch02-viz-aligned}
add.x.var <- function(df, x.var){
  data.frame(df, x.var=factor(x.var, c("life expectancy", "year")))
}
(viz.aligned <- animint(
  scatter=ggplot()+
    theme_bw()+
    theme_animint(width=600)+
    geom_point(aes(
      x=life.expectancy, y=fertility.rate, color=Region),
      data=add.x.var(WorldBank1975, "life expectancy"))+
    geom_path(aes(
      x=life.expectancy, y=fertility.rate, color=Region,
      group=country),
      data=add.x.var(WorldBankBefore1975, "life expectancy"))+
    geom_line(aes(
      x=year, y=fertility.rate, color=Region, group=country),
      data=add.x.var(WorldBankSome, "year"))+
    xlab("")+
    facet_grid(. ~ x.var, scales="free")))
```

La visualisation de données ci-dessus contient un seul ggplot avec deux panneaux et trois couches.
Le panneau de gauche montre les `geom_point` et `geom_path` et le panneau de droite montre les `geom_line`.
Les panneaux ont un axe commun pour le taux de fécondité, ce qui garantit que les lignes dans le panel des séries temporelles
peuvent être directement comparées aux points et aux trajectoires dans le nuage de points.

Il est à noter que nous avons utilisé la fonction `add.x.var` pour ajouter un `x.var` à chaque ensemble de données,
puis nous avons utilisé cette variable variable dans `facet_grid(scales="free")`.
C'est ce que nous appelons la [addColumn then facet idiom](Ch99-appendix.html#addColumn-then-facet),
qui est généralement utile pour créer des données multi-panneaux avec des axes alignés.
En particulier, si nous voulions changer l'ordre des panneaux dans la visualisation de données, il nous suffirait modifier
l'ordre des niveaux de facteurs dans la définition de `add.x.var`.

Notez également que `theme_bw` signifie qu'il faut utiliser des bordures de panneaux noires et des arrière-plans de panneaux blancs,
et `panel.margin=0` signifie qu'il n'y a pas d'espace entre panneaux.
L'élimination de l'espace entre les panneaux signifie que plus d'espace sera utilisé pour les panneaux, ce qui permet de mettre l'accent sur les données.
C'est ce que nous appelons [L'idiome des facettes d'économie d'espace](Ch99-appendix.html#space-saving-facets),
qui est généralement utile dans tout ggplot avec facettes.

Dans l'image de données ci-dessus, les étiquettes de texte se chevauchent un peu, ce qui peut être corrigé par (exercice pour le lecteur)

- l'utilisation l'argument `breaks` de `scale_x_continuous()`
- la réduction de la taille du texte avec `theme()` et `element_text()`
- l'augmentation de la largeur de la parcelle à l'aide de `theme_animint()` voir [Chapitre 6](Ch06-other.html#plot-height-width) pour plus d'informations.

### Mêmes géomes dans chaque panneau (comparaison de sous-ensembles de données) {#compare-data-subsets}

La deuxième raison d'utiliser des graphiques avec plusieurs panneaux dans une visualisation de données est de comparer des sous-ensembles d'observations.
Cela facilite la comparaison entre des sous-ensembles de données et peut être utilisé dans au moins deux situations différentes :

- L'ensemble de données d'un géom a trop d'observations pour être affiché de manière informative dans un seul panneau.
- Vous souhaitez comparer différents sous-ensembles de données qui sont tracés pour un geoms.

Prenons l'exemple du croquis ci-dessous.

![Graphique des panels de la Banque mondiale](Ch02-viz-panels.png)

Notez que les trois panneaux représentent les deux mêmes geoms (point et chemin).
Puisqu'il y a `facet=show.year` et qu'il y a trois panneaux, nous devrons créer des tableaux de données contenant trois valeurs
pour la varaible `show.year`. Le `geom_point` n'a des données que pour 3 ans, et la `geom_path` a des données pour 15 ans (mais 3 valeurs pour
`show.year`). Le code ci-dessous crée ces deux ensembles de données pour trois valeurs d'années de l'ensemble de données de la Banque mondiale.

```{r}
show.point.list <- list()
show.path.list <- list()
for(show.year in c(1975, 1985, 1995)){
  show.point.list[[paste(show.year)]] <- data.frame(
    show.year, subset(WorldBank, year==show.year))
  show.path.list[[paste(show.year)]] <- data.frame(
    show.year, subset(WorldBank, show.year - 5 <= year & year <= show.year))
}
show.point <- do.call(rbind, show.point.list)
show.path <- do.call(rbind, show.path.list)
```

Nous avons utilisé une boucle for sur trois valeurs de `show.year`, la variable que nous utiliserons plus tard dans `facet_grid`.
Pour chaque valeur de `show.year` nous stockons un sous-ensemble de données sous la forme d'un élément nommé dans une liste.
Après la boucle for, nous utilisons `do.call` avec `rbind` pour combiner les sous-ensembles de données. Il s'agit d'un exemple de la méthode
[tableau de données idiome](Ch99-appendix.html#list-of-data-tables), qui est généralement utile pour la visualisation interactive des données.

Ci-dessous, nous avons utilisé la facette sur le `show.year` pour créer un fichier de données
avec trois panneaux.

```{r Ch02-viz-panels}
animint(
  scatter=ggplot()+
    geom_point(aes(
      x=life.expectancy, y=fertility.rate, color=Region),
      data=show.point)+
    geom_path(aes(
      x=life.expectancy, y=fertility.rate, color=Region,
      group=country),
      data=show.path)+
    facet_grid(. ~ show.year)+
    theme_bw())
```

La visualisation de données ci-dessus contient un seul ggplot avec trois
panneaux. Elle montre une plus grande partie de l'ensemble des données de la Banque mondiale que les
visualisations précédentes qui ne montraient que les données de 1975. Cependant, on ne voit encore
qu'un sous-ensemble de données relativement restreint. Vous pouvez être tenté d'essayer
d'utiliser un panneau pour afficher toutes les années (et pas seulement 1975, 1985, et
1995\). Cependant, il faut savoir que ce type de données multi-panneaux
n'est particulièrement utile que s'il n'y a que quelques ensembles de données.
Au-delà d'une dizaine de panneaux, il devient difficile de voir toutes les données
en même temps, et donc de faire des comparaisons significatives.

Au lieu d'afficher toutes les données en une seule fois, nous pouvons créer une
visualisation de données animée qui montre à l'observateur différents sous-ensembles
de données au fil du temps. Dans le [chapitre suivant](Ch03-showSelected.html) nous
montrerons comment le nouveau mot clé `showSelected` peut être utilisé pour réaliser des animations
et révéler plus de détails sur cet ensemble de données.

## Résumé du chapitre et exercices {#exercises}

Ce chapitre a présenté les bases de la visualisation de données statique à l'aide de
ggplot2. Nous avons montré comment animint peut être utilisé pour afficher une liste de ggplots
dans un navigateur web. Nous avons expliqué deux caractéristiques de ggplot2 qui le rendent
idéale pour la visualisation de données : les graphiques multi-couches et multi-panneaux.

Exercices :

- Quels sont les trois principaux avantages de la `ggplot2` par rapport aux anciens
  systèmes de traçage antérieurs, tels que `grid` et `lattice`?

- Quel est l'objectif des graphiques multicouches ?

- Quelles sont les deux raisons différentes de créer des graphiques multi-panneaux ?
  Lequel de ces deux types de graphiques est utile pour l'interactivité ?

- Définissons "A \< B" comme signiifiant "un B peut contenir plusieurs A".
  Laquelle des affirmations suivantes est vraie ?
  
  - ggplot \< panel
  - panel \< ggplot
  - ggplot \< animint
  - animint \< ggplot
  - layer \< panel
  - panneau \< couche
  - couche \< ggplot
  - ggplot \< couche

- Dans la couche `viz.aligned` pourquoi est-il important d'utiliser l'argument `scales="free"` argument ?

- Dans le cadre de `viz.aligned` nous avons montré un ggplot avec un panneau de nuage de points sur le panneau de
  à gauche et un panneau de séries temporelles à droite. Réalisez une autre version de
  de la visualisation de données avec le panneau de séries temporelles à gauche et le nuage de points à droite.

- En `viz.aligned` le nuage de points affiche le taux de fécondité et le taux d'espérance de vie,
  mais la série temporelle n'affiche que le taux de fécondité. Faites
  une autre version de la visualisation de données qui montre les deux séries temporelles.
  Conseil : utilisez les panneaux horizontaux et verticaux dans `facet_grid`.

- Utiliser `aes(size=population)` dans le nuage de points pour montrer la population
  de chaque pays. Indice : `scale_size_animint(pixel.range=c(5, 10)`
  signifie qu'il faut utiliser des cercles d'un rayon de 5 (resp. 10) pixels pour
  représenter la population minimale (resp. maximale).

- Créez une visualisation de données à plusieurs panneaux qui montre chaque année de la
  `WorldBank` dans un panneau séparé. Quelles sont les limites
  de l'utilisation de graphiques statiques pour visualiser ces données ?

- Créer `viz.aligned` à l'aide d'un système de traçage qui n'est pas basé sur la grammaire des grpahiques.
  Par exemple, vous pouvez utiliser les fonctions du
  `graphics` du paquet dans R (`plot`, `points`, `lines` etc), ou
  matplotlib en Python. Quels sont les avantages de ggplot2 et de animint ?

Ensuite, le [Chapitre 3](Ch03-showSelected.html) explique le mot clé `showSelected`
qui indique une variable à utiliser pour avoir des sous-ensembles de données
avant le tracé.


