# Techniques de programmation pour la visualisation

<!-- paragraph -->

```{r setup, echo=FALSE}
knitr::opts_chunk$set(fig.path="ch99-figures/")
```

<!-- paragraph -->

Cette annexe décrit plusieurs techniques de programmation R utiles dans la création des animints.

<!-- paragraph -->

## Facettes économes en espace {#space-saving-facets}

<!-- paragraph -->

Pour mettre l’accent sur les données graphiques dans les ggplots à facettes, éliminez l’espace entre les facettes à l’aide du code suivant :

<!-- paragraph -->

```{r, eval=FALSE}
ggplot()+
  geom_point(aes(Petal.Width, Sepal.Width), iris)+
  theme_bw()+
  theme(panel.margin=grid::unit(0, "lines"))+
  facet_grid(. ~ Species)
```

<!-- paragraph -->

Ce code comprend trois parties :

<!-- paragraph -->

- `panel.margin=0` élimine l’espace entre les panneaux.
<!-- comment -->
- `theme_bw` active un thème noir et blanc (bordures de panneaux noires et arrière-plans de panneaux blancs), ce qui rend visibles les limites entre les panneaux, une étape nécessaire, puisque la fonction par défaut de ggplot `theme_grey` utilise des fonds de panneaux gris et pas de bordures de panneaux. 

<!-- comment -->
- `facet_*` crée un ggplot multipanneaux.

<!-- paragraph -->

Notez que nous utilisons l’unité de grille `lines`, qui correspond à la hauteur d’une ligne de texte de la taille par défaut.
<!-- comment -->
C’est la seule unité de grille qu’animint sait traduire.
<!-- comment -->
L’utilisation d’autres unités telles que `cm` n’est pas recommandée.

<!-- paragraph -->

## Liste de tableaux de données {#list-of-data-tables}

<!-- paragraph -->

Les tableaux de données sont très utiles pour créer des visualisations de données interactives, quelle que soit leur complexité.
<!-- comment -->
Leur structure générale est la suivante :

<!-- paragraph -->

```{r, eval=FALSE}
library(data.table)
outer.data.list <- list()
inner.data.list <- list()
for(outer in outer.vec){
  outer.dt <- computeOuter(outer)
  outer.data.list[[paste(outer)]] <- data.table(outer, outer.dt)
  for(inner in inner.vec){
    inner.dt <- computeInner(outer.dt, inner)
    inner.data.list[[paste(outer, inner)]] <-
      data.table(outer, inner, inner.dt)
  }
}
outer.data <- do.call(rbind, outer.data.list)
inner.data <- do.call(rbind, inner.data.list)
```

<!-- paragraph -->

Quelques commentaires :

<!-- paragraph -->

- La première partie consiste à initialiser des listes vides.
<!-- comment -->
Il y en a deux ci-dessus, `outer.data.list` et `inner.data.list`, mais on peut en initialiser autant que nécessaire .
<!-- comment -->
- La deuxième partie est un ensemble de boucles for imbriquées qui assignent des tableaux de données aux éléments de ces listes.
<!-- comment -->
- Des fonctions comme `computeOuter` et `computeInner` peuvent être utilisées, mais il est également possible d’effectuer simplement les calculs directement dans la boucle for.
<!-- comment -->
- Pour optimiser la rapidité de votre code, utilisez les opérations matrice-vecteur ou vecteur-scalaire dans la boucle for la plus interne.
<!-- comment -->
Si vous n’effectuez que des opérations scalaires-scalaires dans votre boucle for interne, vous améliorerez les performances de votre code en supprimant cette boucle for et en réécrivant le calcul en termes d’opérations vectorielles-scalaires.
<!-- comment -->
- `paste()` est utilisée pour nommer le `data.table` dans la liste de résultats.
<!-- comment -->
Bien qu'on puisse utiliser `data.frame` ou `data.table`, en pratique `data.table` est souvent bien plus rapide lors de l’étape finale de combinaison.
<!-- comment -->
- La dernière partie utilise `do.call` avec `rbind` pour combiner les tableaux de données stockés au cours des boucles for.

<!-- paragraph -->

## Rajouter une colonne et des facettes {#addColumn-then-facet}

<!-- paragraph -->

Cette technique est utile pour créer des ggplots multipanneaux avec des axes alignés.
<!-- comment -->
Tout d’abord, définissez une fonction dont les arguments sont un tableau de données et une ou plusieurs valeurs qui serviront à ajouter des facteurs à ce tableau.

<!-- paragraph -->

```{r, eval=FALSE}
addColumn <- function(df, time.period)data.frame(
  df, time.period=factor(time.period, c("1975", "1960-2010")))
animint(
  ggplot()+
  geom_point(aes(
    x=life.expectancy, y=fertility.rate, color=region),
    data=addColumn(WorldBank1975, "1975"))+
  geom_path(aes(
    x=life.expectancy, y=fertility.rate, color=region,
    group=country),
    data=addColumn(WorldBankBefore1975, "1975"))+
  geom_line(aes(
    x=year, y=fertility.rate, color=region, group=country),
    data=addColumn(WorldBank, "1960-2010"))+
  facet_grid(. ~ time.period, scales="free")+
  xlab(""))
```

<!-- paragraph -->

Notez que `scales="free"` et `xlab("")` sont utilisés, car les axes x ont maintenant des unités très différentes (année et espérance de vie).

<!-- paragraph -->

## Légendes de couleurs manuelles {#manual-color-legends}

<!-- paragraph -->

On peut utiliser `scale_color_manual()` et `scale_fill_manual()` pour préciser les couleurs dans les légendes pour `aes(color)` et `aes(fill)`.
<!-- comment -->
En règle générale, on choisit l’une des palettes ColorBrewer :

<!-- paragraph -->

```{r, fig.height=8}
RColorBrewer::display.brewer.all()
```

<!-- paragraph -->

Par exemple, pour obtenir le code R de la palette Set1, nous écrivons :

<!-- paragraph -->

```{r}
dput(RColorBrewer::brewer.pal(7, "Set1"))
```

<!-- paragraph -->

Nous copions ensuite ce code R depuis le terminal et le collons dans l’éditeur de texte.

<!-- paragraph -->

```{r}
data(WorldBank, package="animint2")
region.colors <- c(
  "#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", 
  "#A65628")
names(region.colors) <- levels(WorldBank$region)
region.colors
```

<!-- paragraph -->

Nous pouvons ensuite l’utiliser avec `scale_color_manual()`.

<!-- paragraph -->

```{r}
library(animint2)
ggplot()+
  scale_color_manual(values=region.colors)+
  geom_point(aes(
    x=life.expectancy, y=fertility.rate, color=region),
    data=WorldBank)
```

<!-- paragraph -->


