# Vélos de Montréal

<!-- paragraph -->

```{r setup, echo=FALSE}
knitr::opts_chunk$set(fig.path="ch09-figures/")
```

<!-- paragraph -->

Dans ce chapitre, nous explorons plusieurs visualisations pour un ensemble de données portant sur le vélo à Montréal.

<!-- paragraph -->

Plan du chapitre :

<!-- paragraph -->

- Nous commençons par quelques séries temporelles non interactives.
<!-- comment -->
- Nous créons une visualisation interactive de la fréquence des accidents dans le temps.
<!-- comment -->
- Nous créons une visualisation interactive avec quatre graphiques, montrant la tendance mensuelle des accidents, les détails quotidiens et une carte de l’emplacement des compteurs.

<!-- paragraph -->

## Graphiques statiques {#bike-static}

<!-- paragraph -->

Nous commençons par charger le fichier `montreal.bikes`, non disponible dans la version CRAN de `animint2` par souci d’économie d’espace.
<!-- comment -->
Pour accéder à ce jeu de données, vous devrez donc installer `animint2` depuis GitHub :

<!-- paragraph -->

```{r ghinstall}
tryCatch({
  data(montreal.bikes, package="animint2")
}, warning=function(w){
  devtools::install_github("animint/animint2")
  data(montreal.bikes, package="animint2")
})
```

Les données se composent de deux séries temporelles :

* `montreal.bikes$counter.counts` : les passages de vélos enregistrés par les compteurs, disposés dans un tableau avec une ligne pour chaque combinaison de lieu et de jour.
<!-- comment -->
* `montreal.bikes$accidents` : les accidents, dans un tableau avec une ligne par accident.

Nous calculerons des résumés mensuels de ces deux séries temporelles.

### Compteurs

Pour commencer, nous affichons le tableau de données des compteurs de vélos :

```{r counterRange}
mois_str <- function(POSIXct)strftime(POSIXct, "%Y-%m")
library(data.table)
(passages_dt <- data.table(montreal.bikes$counter.counts)[, .(
  lieu = location,
  date,
  mois.str = mois_str(date),
  passages=count)])
```

Ci-dessus, on voit une ligne pour chaque combinaison de lieu et de jour.
<!-- comment -->
Le comptage de vélos présente des données de séries temporelles que nous visualisons ci-dessous :

<!-- paragraph -->

```{r countervis}
passages_dt[, lieu.lines := gsub("[- _]", "\n", lieu)]
library(animint2)
ggplot()+
  theme_bw()+
  theme(panel.margin=grid::unit(0, "lines"))+
  facet_grid(lieu.lines ~ .)+
  geom_point(aes(
    date, passages, color=passages==0),
    shape=21,
    data=passages_dt)+
  scale_color_manual(values=c("TRUE"="grey", "FALSE"="black"))
```

<!-- paragraph -->

Le graphique ci-dessus permet de distinguer facilement la différence entre les zéros (en gris) et les valeurs manquantes.
On voit bien la régularité saisonnière (moins de vélos en hiver).

### Accidents

Pour aborder les données d’accidents, nous affichons cette ligne :

```{r}
montreal.bikes$accidents[1,]
```

<!-- paragraph -->

Pour chaque accident, il y a des données sur la date, l’heure, la localisation et le nombre de morts et de blessés.
<!-- comment -->
Certaines valeurs sont en français (par exemple : `Voie de circulation`, `En intersection`, etc.).
<!-- comment -->
Nous allons remplacer les noms de colonnes en anglais par des termes en français :

<!-- paragraph -->

```{r}
gravité <- c(
  décès="deaths",
  grave="people.severely.injured",
  mineure="people.slightly.injured")
montreal.bikes$accidents[, names(gravité)] <-
  montreal.bikes$accidents[, gravité]
accidents_dt <- data.table(montreal.bikes$accidents[, c(
  "date.str", "time.str", names(gravité),
  "street", "street.number", "cross.street")])
```

<!-- paragraph -->

Dans le code ci-dessous, nous rajoutons une colonne pour le mois :

<!-- paragraph -->

```{r timeRange}
ymd2POSIXct <- function(date.str){
  as.POSIXct(strptime(date.str, "%Y-%m-%d"))
}
(accidents_dt[
, date := ymd2POSIXct(date.str)
][
, mois.str := mois_str(date)
][])
```

<!-- paragraph -->

Dans la sortie ci-dessus, on voit que les derniers mois pour les accidents ne sont pas les mêmes que pour les compteurs. On compare les intervalles dans le code ci-dessous :

```{r}
data.list <- list(accidents=accidents_dt, passages=passages_dt)
sapply(data.list, function(DT)range(DT$mois.str))
```

Dans la sortie ci-dessus, on voit que les passages et les accidents se chevauchent.
<!-- comment -->
Nous allons compiler des résumés mensuels, d’où la création du tableau de données ci-dessous :

<!-- paragraph -->

```{r months}
uniq.mois.vec <- sort(unique(unlist(lapply(
  data.list, "[[", "mois.str"))))
mois_01 <- function(mois)ymd2POSIXct(paste0(mois, "-01"))
mois_dt <- data.table(mois.01 = mois_01(uniq.mois.vec))
```

Le code ci-dessous définit l’environnement linguistique (locale en anglais) pour présenter les mois en français :

```{r}
old.locale <- Sys.setlocale(locale="fr_CA.UTF-8")
mois_français_str <- function(POSIXct)strftime(POSIXct, "%B %Y")
mois.levs <- mois_français_str(mois_dt$mois.01)
mois_français <- function(POSIXct)factor(
  mois_français_str(POSIXct), mois.levs)
mois_dt[, mois.français := mois_français(mois.01)][]
```

<!-- paragraph -->

La sortie ci-dessus comprend une ligne pour chaque mois.
<!-- comment -->
Notez que nous avons créé une colonne `mois.français` qui sera utilisée comme variable de sélection pour les mois.
<!-- comment -->
Dans le code ci-dessous, nous calculons la somme des accidents par mois :

```{r}
(accidents.par.mois <- dcast(
  accidents_dt,
  mois.str ~ .,
  sum,
  value.var=names(gravité)))
```

Ci-dessus on voit une ligne pour chaque mois, avec différentes colonnes pour chaque niveau de gravité.
<!-- comment -->
Nous convertissons ces colonnes en lignes avec le code ci-dessous :

```{r}
(accidents.tall <- melt(
  accidents.par.mois,
  measure.vars=names(gravité),
  variable.name="gravité",
  value.name="personnes"))
```

Ci-dessus on voit une ligne pour chaque combinaison de mois et gravité.
<!-- comment -->
Dans le code ci-dessous, nous utilisons ces données pour créer un graphique montrant le nombre d’accidents par mois :

<!-- paragraph -->

```{r accidentsPerMonth}
gravité.colors <- c(
  mineure="#FEE0D2",#lite red
  grave="#FB6A4A",
  décès="#A50F15")#dark red
ggplot()+
  theme_bw()+
  geom_bar(aes(
    mois_01(mois.str), personnes, fill=gravité),
    stat="identity",
    data=accidents.tall)+
  scale_fill_manual(
    values=gravité.colors, breaks=names(gravité.colors))+
  scale_x_datetime("mois")
```

Ci-dessus, on voit le nombre de personnes décédées et blessées au fil du temps.

## Visualisation interactive de la fréquence des accidents {#regression}

Nous voulons maintenant comparer, pour chaque mois, les données de compteurs et d’accidents.
<!-- comment -->
Est-ce que nous avons plus d’accidents quand il y a plus de passages en vélo ?
Pour le vérifier, nous devons calculer un résumé des passages par mois avec le code ci-dessous :

```{r}
(passages.par.mois <- dcast(
  passages_dt[!is.na(passages)],
  lieu + mois.str ~ .,
  list(length, mean, sum),
  value.var="passages"))
```

La sortie ci-dessus contient une ligne pour chaque combinaison de lieu et mois, avec des colonnes pour :

* `passages_length` : le nombre de jours.
* `passages_mean` : la moyenne de passages par jour.
* `passages_sum` : le nombre total de passages.

On remarque qu’il manque des journées pour certains mois. Par exemple, il n’y a que 29 jours pour `Berri` en avril 2009, et 18 jours pour `Totem_Laurier` en septembre 2013.
<!-- comment -->
Pour modéliser seulement les mois complets, nous devons exclure ceux avec des journées manquantes.
<!-- comment -->
On utilise le code ci-dessous pour calculer le nombre de jours dans chaque mois :

```{r}
un.jour <- 60 * 60 * 24
mois_suivant <- function(POSIXct)mois_01(POSIXct + un.jour * 31)
passages.par.mois[, jours.dans.mois := as.integer(round(difftime(
  mois_01(mois_str(mois_suivant(mois_01(mois.str)))),
  mois_01(mois.str),
  units="days"
)))][]
```

Dans la sortie ci-dessus, on voit la nouvelle colonne `jours.dans.mois`.
<!-- comment -->
Avec le code ci-dessous, on affiche seulement les mois avec des jours manquants :

```{r}
passages.par.mois[
  passages_length < jours.dans.mois,
  .(lieu, mois.str, passages_length, jours.dans.mois)]
```

Nous allons exclure les données obtenues, en utilisant le code ci-dessous :

```{r}
mois.complets <- passages.par.mois[passages_length == jours.dans.mois]
```

Ensuite, nous créons un tableau avec les passages et les accidents dans des colonnes distinctes :

```{r}
city.wide.complete <- mois.complets[passages_sum>0, .(
  lieux=.N,
  total.passages=sum(passages_sum)
), keyby=mois.str]
city.wide.accidents <- accidents_dt[, .(
  total.accidents=.N
), keyby=mois.str]
(scatter.not.na <- city.wide.accidents[
  city.wide.complete, nomatch=0L
][, mois.01 := mois_01(mois.str)][])
```

Dans la sortie ci-dessus, on voit une ligne pour chaque mois avec les données de passages et d’accidents.
<!-- comment -->
Ensuite, nous faisons un modèle linéaire pour prédire les accidents à partir des passages :

```{r}
(fit <- lm(total.accidents ~ total.passages - 1, scatter.not.na))
scatter.not.na[, mean(total.accidents/total.passages)]
scatter.not.na[, sum(total.accidents)/sum(total.passages)]
```

Dans la sortie ci-dessus, on voit que le coefficient du modèle est proche des moyennes empiriques.
<!-- comment -->
Enfin, nous créons un graphique interactif avec le code ci-dessous.

```{r ch09-vis-regression}
scatter.not.na[, let(
  pred.accidents = predict(fit),
  mois.français = mois_français(mois.01)
)]
animint(
  regression=ggplot()+
    theme_bw()+
    ggtitle("Accidents et passages par mois")+
    geom_line(aes(
      total.passages, pred.accidents),
      color="grey",
      data=scatter.not.na)+
    geom_point(aes(
      total.passages, total.accidents),
      clickSelects="mois.français",
      size=5,
      alpha=0.75,
      data=scatter.not.na)+
    ylab("Accidents par mois")+
    xlab("Passages par mois"),
  timeSeries=ggplot()+
    theme_bw()+
    ggtitle("Série temporelle : fréquence des accidents")+
    xlab("mois")+
    geom_point(aes(
      mois.01, total.accidents/total.passages),
      clickSelects="mois.français",
      size=5,
      alpha=0.75,
      data=scatter.not.na))
```

La visualisation des données ci-dessus contient deux graphiques reliés.
<!-- comment -->
Le graphique de gauche montre que le nombre d’accidents augmente avec le nombre de cyclistes.
<!-- comment -->
Le graphique de droite montre la fréquence des accidents au fil du temps.

<!-- paragraph -->

## Visualisation interactive avec carte et détails {#details}

<!-- paragraph -->

Dans cette section, nous allons faire une visualisation composée des éléments suivants :

* Résumé des compteurs : carte des compteurs ou min/max des mois pour chaque compteur, pour sélectionner un compteur.
<!-- comment -->
* Détails d’un compteur, résumé des mois : séries temporelles par mois, pour les accidents et les données d’un compteur. Cliquer pour sélectionner un mois.
<!-- comment -->
* Détails d’un compteur et d’un mois : séries temporelles par jour, pour le mois sélectionné.

### Résumé des compteurs avec carte

Les données `counter.locations` contiennent l’emplacement géographique de chaque compteur.
<!-- comment -->
Pour examiner ces données, il faut d’abord convertir le nom en Unicode :

```{r}
(counter.locations <- data.table(montreal.bikes$counter.locations)[, .(
  lon = coord_X, lat = coord_Y,
  nom_comptage=iconv(nom_comptage, "latin1", "UTF-8"))])
```

Dans la sortie ci-dessus, on voit que la colonne `nom_comptage` indique l’emplacement, mais ce ne sont pas exactement les mêmes valeurs que la colonne `lieu` dans les données de passages.
<!-- comment -->
On utilise le code ci-dessous pour établir une correspondance entre les tableaux :

```{r}
loc.name.code <- c(
  Berri1="Berri",
  Brebeuf="Brébeuf",
  CSC="Côte-Sainte-Catherine",
  Maisonneuve_1="Maisonneuve 1",
  Maisonneuve_2="Maisonneuve 2",
  Parc="du Parc",
  PierDup="Pierre-Dupuy",
  "Rachel/Papineau"="Rachel",
  "Saint-Urbain"="Saint-Urbain",
  Totem_Laurier="Totem_Laurier")
(show.locations <- counter.locations[
, lieu := loc.name.code[nom_comptage]
][!is.na(lieu)])
```

La sortie ci-dessus contient l’emplacement géographique de chaque compteur.
<!-- comment -->
L’emplacement des compteurs est tracé ci-dessous :

```{r}
map.lim <- show.locations[, lapply(.SD, range), .SDcols=c("lat","lon")]
diff.vec <- sapply(map.lim, diff)
diff.mat <- c(-1, 1) * matrix(diff.vec, 2, 2, byrow=TRUE)
scale.mat <- as.matrix(map.lim) + diff.mat
bike.paths <- data.table(montreal.bikes$path.locations)
show.paths <- bike.paths[(
  lat %between% scale.mat[, "lat"]
) & (
  lon %between% scale.mat[, "lon"]
)]
(mtl.map <- ggplot()+
   theme_bw()+
   theme(
     panel.margin=grid::unit(0, "lines"),
     axis.line=element_blank(), axis.text=element_blank(),
     axis.ticks=element_blank(), axis.title=element_blank(),
     panel.background = element_blank(),
     panel.border = element_blank())+
   coord_cartesian(xlim=map.lim$lon, ylim=map.lim$lat)+
   scale_x_continuous(limits=map.lim$lon)+
   scale_y_continuous(limits=map.lim$lat)+
   geom_path(aes(
     lon, lat,
     tooltip=TYPE_VOIE,
     group=paste(feature.i, path.i)),
     color="grey",
     data=show.paths)+
   geom_text(aes(
     lon, lat,
     label=lieu),
     clickSelects="lieu",
     data=show.locations))
```

La sortie ci-dessus est un plan de Montréal où chacun des dix compteurs est représenté par du texte.

### Résumé des dates extrêmes pour chaque compteur

Maintenant on calcule les dates extrêmes pour chaque compteur :

```{r}
(location.ranges <- dcast(
  passages.par.mois[0 < passages_sum][
  , mois.01 := mois_01(mois.str)],
  lieu ~ .,
  list(min, max),
  value.var="mois.01"))
```

Dans la sortie ci-dessus, on voit une ligne pour chaque compteur, avec des colonnes pour les dates extrêmes.
<!-- comment -->
Le graphique ci-dessous montre la période pendant laquelle chaque compteur a fonctionné.

```{r}
location.colors <- c(#dput(RColorBrewer::brewer.pal(12, "Set3"))
  "#8DD3C7", "grey50", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462",
  "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD", "#CCEBC5", "#FFED6F")
names(location.colors) <- show.locations$lieu
seg.size <- 10
(CounterRanges <- ggplot()+
  theme_bw()+
  xlab("min/max dates")+
  ylab("source de données")+
  scale_color_manual(values=location.colors)+
  guides(color="none")+
  geom_segment(aes(
    mois.01_min, lieu,
    xend=mois.01_max, yend=lieu),
    showSelected="lieu",
    data=location.ranges,
    size=seg.size+2)+
  geom_segment(aes(
    mois.01_min, lieu,
    xend=mois.01_max, yend=lieu,
    color=lieu),
    clickSelects="lieu",
    data=location.ranges,
    size=seg.size))
```

La sortie ci-dessus contient un segment pour chaque compteur.
<!-- comment -->
Avec le code ci-dessous, nous rajoutons un segment pour les accidents.

```{r}
accidents.range <- dcast(
  data.table(lieu="accidents", accidents_dt),
  lieu ~ .,
  list(min, max),
  value.var="date")
(MonthSummary <- CounterRanges+
  geom_segment(aes(
    date_min, lieu,
    xend=date_max, yend=lieu),
    color=gravité.colors[["décès"]],
    data=accidents.range,
    size=seg.size))
```

Dans la sortie ci-dessus, on voit un segment de plus (pour les accidents en bas).

### Séries temporelles mensuelles

Le graphique ci-dessous présente le comptage de vélos à chaque localisation, chaque jour :

```{r}
ggplot()+
  theme_bw()+
  geom_line(aes(
    date, passages, group=lieu),
    data=passages_dt)+
  scale_color_manual(values=location.colors)+
  geom_point(aes(
    date, passages, color=lieu),
    data=passages_dt)
```

<!-- paragraph -->

Le graphique ci-dessous reprend les mêmes données, mais pour chaque mois :

<!-- paragraph -->

```{r}
FACET <- function(DT, facet)data.table(DT, facet)
COMPTEURS <- function(DT)FACET(DT, "passages/jour")
(MonthSeries <- ggplot()+
  guides(color="none")+
  theme_bw()+
  facet_grid(facet ~ ., scales="free")+
  geom_tallrect(aes(
    xmin=mois.01-15*un.jour, xmax=mois.01+15*un.jour),
    clickSelects="mois.français",    
    data=mois_dt,
    alpha=1/2)+
  geom_line(aes(
    mois_01(mois.str), passages_mean, group=lieu,
    color=lieu),
    showSelected="lieu",
    clickSelects="lieu",
    data=COMPTEURS(passages.par.mois))+
  scale_color_manual(values=location.colors)+
  xlab("mois")+
  ylab(""))
```

Le graphique ci-dessus contient une ligne pour chaque compteur.
<!-- comment -->
Dans le code ci-dessous, nous ajoutons deux geoms :

```{r}
mois.text <- passages.par.mois[
, .SD[which.max(passages_mean)]
, by=lieu]
(MonthText <- MonthSeries+
  geom_point(aes(
    mois_01(mois.str), passages_mean, color=lieu,
    tooltip=paste(
      passages_mean, "vélos à",
      lieu, "en", mois_français(mois_01(mois.str)))),
    showSelected="lieu",
    clickSelects="lieu",
    size=5,
    data=COMPTEURS(passages.par.mois))+
  geom_text(aes(
    mois_01(mois.str), passages_mean+300,
    color=lieu, label=lieu),
    showSelected="lieu",
    clickSelects="lieu",
    data=COMPTEURS(mois.text)))
```

Le graphique ci-dessous intègre les accidents :

```{r}
ACCIDENTS <- function(DT)FACET(DT, "accidents")
(MonthFacet <- MonthText+
   facet_grid(facet ~ ., scales="free")+
   scale_fill_manual(
     values=gravité.colors, breaks=names(gravité.colors))+
   geom_bar(aes(
     mois_01(mois.str), personnes,
     fill=gravité),
     showSelected="gravité",
     stat="identity",
     position="identity",
     color=NA,
     data=ACCIDENTS(accidents.tall[order(-gravité)])))
```

Dans la sortie ci-dessus, on voit les deux sources de données (accidents et compteurs).

### Détails pour un mois

Dans cette section, nous voulons créer un graphique des accidents pour chaque mois, avec un point pour chaque personne qui a eu un accident.
<!-- comment -->
Ci-dessous, nous classons chaque accident selon le degré de gravité pour les personnes touchées.

```{r}
accidents_dt[, gravité.str := fcase(
  0 < décès, "décès",
  0 < grave, "grave",
  default="mineur"
)][
, gravité := factor(gravité.str, names(gravité.colors))
][, table(gravité)]
```

Le résultat ci-dessus montre que les accidents avec blessures mineures sont les plus fréquents, tandis que ceux avec décès sont les moins fréquents.
<!-- comment -->
Dans le code ci-dessous, nous créons une colonne `accident.i` qui attribue un numéro unique à chaque accident de la journée.

```{r}
jour_du_mois <- function(POSIXct)as.integer(strftime(POSIXct, "%d"))
add_jour_mois <- function(DT)DT[, let(
  jour.du.mois = jour_du_mois(date),
  mois.français = mois_français(date))]
accidents.cumsum <- add_jour_mois(accidents_dt[
  order(date, -gravité)
][
, accident.i := seq_len(.N)
, by=date
])
ggplot()+
  theme_bw()+
  theme(panel.margin=grid::unit(0, "cm"))+
  facet_wrap("mois.str")+
  scale_fill_manual(values=gravité.colors)+
  scale_x_continuous("jour du mois", breaks=c(1, 10, 20, 30))+
  geom_point(aes(
    jour.du.mois, accident.i, fill=gravité),
    data=accidents.cumsum)
```

Dans la sortie ci-dessus, on voit un point pour chaque accident.
<!-- comment -->
Le code ci-dessous permet ensuite de créer une grille de jours  :

```{r}
(days.dt <- mois_dt[, .(date=seq(
  min(mois.01),
  max(mois_suivant(mois.01)),
  by="day"
))][#jour de la semaine :
, jds := strftime(date, "%a")
][])
```

La sortie ci-dessus contient une ligne pour chaque jour dans la période d’observation.
<!-- comment -->
Le code ci-dessous, trace un tableau pour souligner les fins de semaine :

```{r}
(weekend.dt <- add_jour_mois(days.dt[
  grepl("sam|dim", jds)#windows="sam." ubuntu="sam"
])[])
```

La sortie ci-dessus contient une ligne pour chaque jour de fin de semaine.
<!-- comment -->
Nous créons ensuite un tableau pour afficher le nom de chaque lieu :
```{r}
add_jour_mois(passages_dt)
(jour.text <- passages_dt[
, .SD[which.max(passages)]
, by=.(lieu, mois.français)])
```

La sortie ci-dessus contient le jour avec le plus de passages, pour chaque lieu et mois.
<!-- comment -->
Le code ci-dessous trace ensuite un graphique de passages quotidiens enregistrés par les compteurs :

```{r}
(DaysCompteurs <- ggplot()+
  geom_tallrect(aes(
    xmin=jour.du.mois-0.5, xmax=jour.du.mois+0.5,
    key=paste(date)),
    showSelected="mois.français",
    fill="grey",
    color="white",
    data=weekend.dt)+
  guides(color="none", fill="none")+
  theme_bw()+
  facet_grid(facet ~ ., scales="free")+
  geom_line(aes(
    jour.du.mois, passages, group=lieu,
    key=lieu, color=lieu),
    showSelected=c("lieu", "mois.français"),
    clickSelects="lieu",
    chunk_vars=c("mois.français"),
    data=COMPTEURS(passages_dt))+
  scale_color_manual(values=location.colors)+
  ylab("")+
  geom_point(aes(
    jour.du.mois, passages, color=lieu,
    key=paste(jour.du.mois, lieu),
    tooltip=paste(
      passages, "cyclistes à",
      lieu, "en",
      date)),
    showSelected=c("lieu", "mois.français"),
    clickSelects="lieu",
    size=5,
    chunk_vars=c("mois.français"),
    fill="white",
    data=COMPTEURS(passages_dt)))
```

La sortie ci-dessus affiche les données des compteurs, mais elle est surchargée car le graphique statique ne prend pas en compte le mot-clé `showSelected`.
<!-- comment -->
Le code ci-dessous ajoute les données d’accidents :

```{r}
(DaysFacet <- DaysCompteurs+
   scale_fill_manual(
     values=gravité.colors, breaks=names(gravité.colors))+
   geom_text(aes(
     15, 23, label=mois.français, key=1),
     showSelected="mois.français",
     data=ACCIDENTS(mois_dt))+
   scale_x_continuous("jour du mois", breaks=c(1, 10, 20, 30))+
   geom_point(aes(
     jour.du.mois, accident.i,
     key=paste(date.str, accident.i),
     fill=gravité),
     showSelected=c("gravité","mois.français"),
     size=4,
     chunk_vars=c("mois.français"),
     data=ACCIDENTS(accidents.cumsum)))
```

La sortie ci-dessus contient les deux séries temporelles (accidents et compteurs).

### Graphique interactif

Enfin, le code ci-dessous combine tous les graphiques :

```{r ch09-vis-mtl}
animint(
  MonthFacet+
    ggtitle("Toutes les données, choisir mois"),
  DaysFacet+
    ggtitle("Mois sélectionné (week-ends en gris)")+
    geom_label_aligned(aes(
      jour.du.mois, passages+1500, color=lieu, label=lieu,
      key=lieu),
      showSelected=c("lieu", "mois.français"),
      clickSelects="lieu",
      data=COMPTEURS(jour.text))+
    theme_animint(last_in_row=TRUE),
  MonthSummary+theme_animint(width=450, height=250),
  mtl.map+theme_animint(height=250),
  selector.types=list(severity="multiple"),
  duration=list(mois.français=2000),
  first=list(
    lieu="Maisonneuve 2",
    mois.français="juillet 2012"))
```

La sortie ci-dessus contient quatre graphiques :

* En haut à gauche : séries temporelles avec résumé pour chaque mois.
<!-- comment -->
* En haut à droite : séries temporelles pour le mois sélectionné.
<!-- comment -->
* En bas à gauche : les dates min et max pour chaque source de données.
<!-- comment -->
* En bas à droite : emplacement des compteurs sur le plan de Montréal.

## Résumé du chapitre et exercices {#ch09-exercises}

Nous avons vu plusieurs graphiques pour visualiser les séries temporelles en rapport avec les vélos à Montréal.

Exercices :

<!-- paragraph -->

- Transformez la variable `lieu` en variable à sélection multiple.
<!-- comment -->
- Sur la carte, dessinez un cercle avec `aes(color=lieu)` pour chaque compteur, dont la taille varie en fonction des passages dans le mois sélectionné.
<!-- comment -->
- Sur le graphique `MonthSummary` et ajoutez des rectangles en arrière-plan pour sélectionner le mois.
<!-- comment -->
- Supprimez le graphique `MonthSummary` et ajoutez une visualisation similaire dans un troisième panneau de l’écran dans le graphique `MonthFacet`. Astuce : utilisez `theme_animint(rowspan=2)`.
<!-- comment -->
- Dans `DaysFacet`, utilisez `aes(tooltip)` avec quelques détails pour chaque accident (adresse, nombre de personnes, etc.).

<!-- paragraph -->

Dans le [chapitre 10](/ch10), nous vous expliquerons comment visualiser le modèle d’apprentissage automatique des K-voisins les plus proches.

<!-- paragraph -->


