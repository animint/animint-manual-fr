# Limitations

<!-- paragraph -->

```{r}
#| echo: false
knitr::opts_chunk$set(fig.path="ch07-figures/")
```

<!-- paragraph -->

Ce chapitre expose les limites de `animint2` pour certaines tâches de visualisation de données interactives,
<!-- comment -->
et propose quelques solutions de contournement à utiliser dans ces situations.
<!-- comment -->
Après avoir lu ce chapitre, vous saurez comment :

<!-- paragraph -->

- Utiliser une variable normalisée lorsque différents sous-ensembles `showSelected` ont des valeurs très différentes pour une variable que vous souhaitez afficher.
<!-- comment -->
- Calculer les statistiques pour chaque sous-ensemble `showSelected` au lieu d'utiliser les fonctions `stat_*` de `ggplot2`.
<!-- comment -->
- Ajouter des données une par une à un ensemble de variables à sélection multiple, plutôt que d'utiliser un pinceau de sélection rectangulaire.
<!-- comment -->
- Éviter l'utilisation de `vjust` et d'étiquettes à plusieurs lignes dans `geom_text()`.
<!-- comment -->
- Ordonner des graphiques sur une page.
<!-- comment -->
- Éviter l'utilisation des options `theme` non supportées.
<!-- comment -->
- Utiliser des facettes avec plusieurs variables par axe.
<!-- comment -->
- Utiliser le package de serveur web `shiny` pour modifier de manière interactive la cartographie esthétique d'un `animint`, ou pour effectuer des calculs basés sur les valeurs sélectionnées.

<!-- paragraph -->

Toute idée visant à améliorer `animint2` et à contourner l'une de ces limites est la bienvenue. Les développeurs de `animint2` seraient plus qu'heureux d'accepter votre [Pull Request](https://github.com/tdhock/animint2/compare).

<!-- paragraph -->

## Variables normalisées avec `showSelected` {#normalized-variables}

<!-- paragraph -->

Nous implémentons les axes et les légendes de la même manière que dans `ggplot2` : en les calculant une seule fois lors de la première génération du graphique.
<!-- comment -->
Par conséquent, les axes et les légendes de chaque graphique animint ne sont pas interactifs.
<!-- comment -->
Pour la plupart des [visualisations de données animées](/ch03#animation-time), les axes fixes permettent de comprendre facilement comment les données changent simultanément à la variable `time`.

<!-- paragraph -->

Dans certaines situations, il serait utile d'avoir des axes qui se mettent à jour de manière interactive; 
<!-- comment -->
par exemple, lorsque différents sous-ensembles `showSelected` ont des valeurs très différentes pour les variables affichées sur un axe ou une légende.
<!-- comment -->
Dans ce cas, il serait utile d'avoir des axes interactifs qui se mettent à jour et changent en même temps que les données.
<!-- comment -->
Nous disposons d'une prise en charge expérimentale pour cela, voir la [mise à jour axestest](https://github.com/tdhock/animint2/blob/master/tests/testthat/test-renderer4-update-axes-multiple-ss.R) pour plus de détails.

<!-- paragraph -->

## Calcul des statistiques pour chaque sous-ensemble {#stats}

<!-- paragraph -->

Dans `animint2`, nous évitons d’utiliser les statistiques et les positions avec `showSelected`.
<!-- comment -->
Par exemple, considérons le ggplot à facettes ci-dessous :

<!-- paragraph -->

```{r}
set.seed(1)
library(data.table)
random.counts <- data.table(
  lettre = c(replicate(4, LETTERS[1:5])),
  comptage = c(replicate(4, rbinom(5, 50, 0.5))),
  groupe = rep(rep(factor(
    c("bas","haut"), c("haut","bas")
  ), each = 5), 2),
  facette = rep(1:2, each = 10))
library(animint2)
ggstat <- ggplot() +
  geom_bar(aes(
    lettre, comptage, key=paste(lettre, groupe), fill = groupe),
    showSelected="facette",
    data = random.counts,
    stat = "identity",
    position="stack")
ggstat+facet_grid(facette ~ .)
```

Dans le graphique ci-dessus, on constate que `position="stack"` aligne le groupe `bas` avec `comptage=0` dans chaque facette.
Utiliser `showSelected` au lieu des facettes ne donne pas le même résultat.

<!-- paragraph -->

```{r ch07-viz-stat}
animint(ggstat, duration = list(facette = 1000))
```

Dans le graphique ci-dessus, si vous cliquez sur le menu de sélection pour changer `facette=2`, vous verrez que le groupe `bas` n'est plus aligné avec `comptage=0`.
Une solution de contournement consiste à calculer les valeurs à afficher, puis à utiliser `position=identity`, comme dans le code ci-dessous.

<!-- paragraph -->

```{r}
random.cumsums <- random.counts[, data.table(
  cumsum=cumsum(comptage), comptage, groupe),
  by=.(lettre, facette)]
ggidentity <- ggplot() +
  theme_bw()+
  geom_segment(aes(
    x=lettre, xend=lettre,
    y=cumsum, yend=cumsum-comptage,
    key=paste(groupe, lettre),
    color=groupe),
    showSelected="facette",
    data = random.cumsums,
    size=10,
    stat = "identity",
    position="identity")
ggidentity+facet_grid(facette ~ .)
```

<!-- paragraph -->

Notez que nous avons utilisé `geom_segment()` au lieu de `geom_bar()`, mais que l'affichage est semblable.

<!-- paragraph -->

```{r ch07-viz-identity}
animint(ggidentity, duration = list(facette = 1000))
```

Dans le graphique ci-dessus, si vous cliquez sur le menu de sélection pour changer `facette=2`, vous verrez que le groupe `bas` reste aligné avec `cumsum=0`.

## Ajouter des valeurs à la sélection, une à la fois {#multiple-selection}

<!-- paragraph -->

`animint2` ne prend pas en charge la brosse rectangulaire ou le lasso pour définir interactivement un ensemble de valeurs prises en charge.
<!-- comment -->
Au lieu de cela, `animint` prend en charge la sélection multiple en ajoutant des valeurs une par une à l'ensemble de sélection multiple.
<!-- comment -->
Il faut donc utiliser l'option [selector.types](/ch04#selector-types-option) pour déclarer une variable de sélection multiple.

<!-- paragraph -->

## Ajuster `y` au lieu d'utiliser `vjust` {#vjust}

<!-- paragraph -->

Pour l'alignement horizontal du texte, animint prend en charge l'utilisation de `hjust` dans R. Les valeurs les plus courantes sont : 0 pour l'alignement à gauche, 0,5 pour l'alignement au milieu et 1 pour l'alignement à droite.
<!-- comment -->
`animint2` traduit ces trois valeurs `hjust` en propriété `text-anchor` dans la visualisation de données générée.

<!-- paragraph -->

Cependant, `animint` ne prend pas en charge l'alignement vertical du texte à l'aide de `vjust` dans R, car aucune propriété ne permet l'alignement vertical du texte en SVG.

<!-- paragraph -->

```{r}
line.df <- data.frame(just=c(0, 0.5, 1))
text.df <- expand.grid(
  vjust=line.df$just,
  hjust=line.df$just)
gg.lines <- ggplot()+
  theme_bw()+
  geom_vline(aes(xintercept=just), data=line.df, color="grey")+
  geom_hline(aes(yintercept=just), data=line.df, color="grey")
gg.vjust <- gg.lines+
  geom_text(aes(
    hjust, vjust, label="bépo", hjust=hjust, vjust=vjust),
    size=10,
    data=text.df)
gg.vjust+ggtitle("aes(vjust) marche avec affichage non-interactif")
```

<!-- paragraph -->

Notez comment `hjust` et `vjust` sont respectés dans le ggplot statique ci-dessus.
<!-- comment -->
En revanche, considérons le `animint` ci-dessous.
<!-- comment -->
Le graphique de gauche devrait être le même que le ggplot ci-dessus, mais il y a des différences évidentes dans le placement vertical des éléments de texte.

<!-- paragraph -->

```{r ch07-viz-just}
(viz.just <- animint(
  vjust=gg.vjust+
    ggtitle("aes(vjust) ne marche pas avec geom_text"),
  workaround=gg.lines+
    ggtitle("solutions : geom_label_aligned ou modifier y")+
    geom_text(aes(
      hjust, vjust + (0.5-vjust)*0.03 - 0.01,
      label="bépo", hjust=hjust),
      data=text.df)+
    geom_label_aligned(aes(
      hjust+0.25, vjust, label="bépo", hjust=hjust, vjust=vjust),
      data=text.df,
      alignment="horizontal")))
```

<!-- paragraph -->

Les solutions de contournement dans `animint2` sont illustrées dans le panneau de droite ci-dessus.

* Ajuster les valeurs de la position verticale `y` des éléments de texte pour lesquels vous auriez utilisé `vjust`.
* Utiliser `geom_label_aligned()` qui marche avec `vjust`. Pour un exemple, lire le [chapitre 8](/ch08).

<!-- paragraph -->

Il serait possible d'implémenter une prise en charge de `vjust` pour `geom_text()`, mais nous n'avons pas encore eu le temps d'y travailler.
<!-- comment -->
Toute contribution en ce sens sera accueillie avec grand plaisir : n'hésitez pas à soumettre une Pull Request.
<!-- comment -->
Nous avons déjà une [issue](https://github.com/tdhock/animint/issues/148) qui explique comment l'implémenter.

<!-- paragraph -->

## Éviter les sauts de ligne dans les étiquettes de texte {#line-breaks}

<!-- paragraph -->

Lors de l'affichage d'un ggplot à l'aide des périphériques graphiques R habituels, l'utilisation d'un saut de ligne ou d'une nouvelle ligne `\n` dans une étiquette `geom_text()` entraîne l'apparition de plusieurs lignes de texte sur le graphique.

<!-- paragraph -->

```{r}
gg.return <- ggplot()+
  geom_text(aes(
    hjust, vjust, label=sprintf("x=%.1f\ny=%.1f", hjust, vjust)),
    size=3,
    data=text.df)
gg.return
```

<!-- paragraph -->

Cependant, `animint2` ne prend en charge que le tracé de la première ligne de texte.

<!-- paragraph -->

```{r ch07-viz-return}
animint(gg.return)
```

<!-- paragraph -->

La prise en charge de plusieurs lignes dans les étiquettes `geom_text()` serait utile, mais nous n'avons pas encore eu le temps de l'implémenter.
<!-- comment -->
Nous avons créé une [issue](https://github.com/tdhock/animint/issues/149) à ce sujet, et toute Pull Request qui implémente cette fonctionnalité sera acceptée.

<!-- paragraph -->

En attendant, la solution de contournement consiste à utiliser un seul `geom_text()` pour chaque ligne de texte à afficher :

<!-- paragraph -->

```{r ch07-viz-two-lines}
gg.two.lines <- ggplot()+
  geom_text(aes(
    hjust, vjust, label=sprintf("x=%.1f", hjust)),
    size=3,
    data=text.df)+
  geom_text(aes(
    hjust, vjust-0.05, label=sprintf("y=%.1f", vjust)),
    size=3,
    data=text.df)
gg.two.lines
animint(gg.two.lines)
```

<!-- paragraph -->

## Éviter certaines options du thème ggplot {#theme-options}

<!-- paragraph -->

L'un des objectifs de `animint2` est de prendre en charge [toutes les options de thème](http://docs.ggplot2.org/current/theme.html), mais nous n'avons pas encore réussi à toutes les implémenter, faute de temps.
<!-- comment -->
Si vous utilisez une option de thème que `animint2` ne prend pas encore en charge, n'hésitez pas à nous envoyer une Pull Request.
<!-- comment -->
La liste suivante répertorie les options `theme` déjà prises en charge par `animint2` :

<!-- paragraph -->

- `panel.margin` désigne la distance entre les panneaux, et est utilisé dans l'[idiome des facettes d'économie d'espace](/ch99#space-saving-facets) pour l'éliminer.
<!-- comment -->
- `panel.grid.major` est utilisé pour dessiner à l'échelle, les lignes de la grille qui sont désignées par l'argument `breaks`.
<!-- comment -->
- `panel.grid.minor` est utilisé pour dessiner les lignes de la grille entre ses lignes principales.
<!-- comment -->
- `panel.background` est utilisé pour le `<rect>` en arrière-plan de chaque panneau.
<!-- comment -->
- `panel.border` est utilisé pour la bordure `<rect>` de chaque panneau (sur l'arrière-plan `<rect>`).
<!-- comment -->
- `legend.position="none"` fonctionne pour cacher toutes les légendes, mais aucune des autres positions de légende n'est prise en charge (les légendes apparaissent toujours à droite du graphique).

<!-- paragraph -->

Les options de thème suivantes peuvent être définies par `element_blank` pour masquer les axes :

<!-- paragraph -->

- `axis.title`, `axis.title.x`, `axis.title.y` désignent le titre de l'axe.
<!-- comment -->
- `axis.ticks`, `axis.ticks.x`, `axis.ticks.y` désignent les tics de l'axe.
<!-- comment -->
- `axis.line`, `axis.line.x`, `axis.line.y` désignent la ligne d'axe.
<!-- comment -->
- `axis.text`, `axis.text.x`, `axis.text.y` désignent l'étiquette de texte de l'axe, et prennent en charge les arguments `angle` et `hjust` de `element_text`.

<!-- paragraph -->

## Facettes avec plusieurs variables par axe {#facet-strips}

<!-- paragraph -->

`animint2` prend en charge `facet_grid` pour créer des visualisations de données à plusieurs panneaux, mais ne prend en charge que de manière limitée les variables multiples par axe.
<!-- comment -->
Par exemple, le ggplot ci-dessous utilise deux variables pour créer des facettes verticales, ce qui se traduit par deux étiquettes de bande lorsqu'elles sont générées avec `ggplot2`.

<!-- paragraph -->

```{r}
data(intreg)
signals.df <- transform(
  intreg$signals,
  person=sub("[.].*", "p", signal),
  chromosome=sub(".*[.]", "c", signal))
two.strips <- ggplot()+
  theme_animint(height=600)+
  facet_grid(person + chromosome ~ ., scales="free")+
  geom_point(aes(base/1e6, logratio), data=signals.df)
two.strips+ggtitle("two strip labels on the right")
```

<!-- paragraph -->

En comparaison, `animint2` affiche le même `ggplot` ci-dessous en n'utilisant qu'une seule étiquette de bande.

<!-- paragraph -->

```{r ch07-viz-strips}
animint(two.strips+ggtitle("only one strip label"))
```

<!-- paragraph -->

Il serait intéressant de prendre en charge plusieurs étiquettes de bande par axe, mais nous ne l'avons pas encore implémenté.
<!-- comment -->
Si vous souhaitez le faire, nous serions heureux d'accepter votre Pull Request.

<!-- paragraph -->

## Définition interactive de mappings `aes()` à l'aide de shiny {#shiny-aes}

<!-- paragraph -->

Normalement, les mappings `aes()` sont définis une fois dans le code R, et ne peuvent pas être modifiés après l'affichage d'un `animint`.
<!-- comment -->
Une façon de surmonter cette limite est de définir des entrées `shiny` qui sont utilisées comme `aes()` de `animint`, tel que démontré dans l'exemple suivant :

<!-- paragraph -->

```{r, eval=FALSE}
shiny::runApp(system.file(
  "examples", "shiny-WorldBank", package="animint2"))
```

<!-- paragraph -->

## Calcul interactif {#shiny-computation}

<!-- paragraph -->

Une autre limitation de `animint2` est de ne pouvoir afficher que des données préalablement calculées et stockées dans un tableau.
<!-- comment -->
Cela signifie que `animint2` n'est pas approprié lorsqu'il y a trop de sous-ensembles à tracer pour les calculer tous.
<!-- comment -->
Dans ce cas, il serait préférable d'utiliser `shiny`.

<!-- paragraph -->

## Résumé du chapitre et exercices {#ch07-exercises}

<!-- paragraph -->

Nous avons discuté des limites de l'implémentation actuelle de `animint2` et présenté plusieurs solutions de contournement.

<!-- paragraph -->

Exercices :

<!-- paragraph -->

- Réalisez un ggplot à facettes avec `stat_bin` qui ne fonctionnera pas avec `animint2` lorsque la variable facette est utilisée comme variable `showSelected`.
<!-- comment -->
Calculez le statut de chaque facette, et utilisez `stat_identity` pour que votre calcul fonctionne avec `animint2`.
<!-- comment -->
- Faites un ggplot qui s'affiche bien en utilisant `facet_grid(. ~ var, scales="free")`, mais ne s'affiche pas correctement avec `showSelected=var`.
<!-- comment -->
Pour résoudre le problème, calculez une version normalisée de `var` et utilisez-la dans `showSelected`.

<!-- paragraph -->

Dans le [chapitre 8](/ch08), nous vous expliquerons comment créer une visualisation multi-panneaux des données de la Banque mondiale.

<!-- paragraph -->


