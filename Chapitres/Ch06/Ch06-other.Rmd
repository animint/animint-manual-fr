---
title: Options
layout: default
output: bookdown::html_chapter
---



Traduction de l'[anglais](https://github.com/tdhock/animint-book/)
[Ch06-other](https://raw.githubusercontent.com/tdhock/animint-book/master/Ch06-other.Rmd)


<!-- paragraph -->

# Chapitre 6, Options Animint

<!-- paragraph -->

```{r setup, echo=FALSE}
knitr::opts_chunk$set(fig.path="Ch06-figures/")
```

<!-- paragraph -->

Ce chapitre donne une liste complète des nouvelles fonctionnalités qu'`animint2` introduit dans la grammaire des graphiques.
<!-- comment -->
Après avoir lu ce chapitre, vous comprendrez comment personnaliser vos graphiques `animint2` via

<!-- paragraph -->

- les `aes()` `href`, `tooltip` et `id` pour les caractéristiques propres à l'observation ;
<!-- comment -->
- les éléments nommés de `clickSelects` et `showSelected` pour spécifier plusieurs variables de sélection à la fois ;
<!-- comment -->
- l'option `chunk_vars` spécifique au geom ;
<!-- comment -->
- les paramètres de geom `color_off`, `fill_off`, et `alpha_off` pour spécifier comment l'état de la sélection est affiché;
<!-- comment -->
- les paramètres de geom `help` et `title`, texte qui est affiché dans la visite guidée.
<!-- comment -->
- les légendes et les options de hauteur/largeur propres au graphique
<!-- comment -->
- options de visualisation des données globales.

<!-- paragraph -->

## Options spécifiques à l'observation (nouveaux `aes()`) {#new-aesthetics}

<!-- paragraph -->

Cette section explique les nouveaux `aes()` reconnus par `animint2`.

<!-- paragraph -->

### Revue des `aes()` introduits précédemment {#review-aesthetics}

<!-- paragraph -->

Nous allons commencer par discuter des nouveaux `aes()` que nous avons déjà introduits dans les chapitres précédents.

<!-- paragraph -->

[Chapitre 3](Ch03-showSelected.html#duration-key) a également introduit `aes(key)` afin de désigner une variable à utiliser pour des transitions fluides et interprétables.

<!-- paragraph -->

### Hyperliens utilisant `aes(href)` {#aes-href}

<!-- paragraph -->

Le code ci-dessous utilise `animint()` pour tracer une carte des États-Unis.

<!-- paragraph -->

```{r Ch06-viz-href}
library(animint2)
USpolygons <- map_data("state")
animint(
  map=ggplot()+
    ggtitle("click a state to read its Wikipedia page")+
    coord_equal()+
    geom_polygon(aes(
      x=long, y=lat, group=group,
      href=paste0("http://en.wikipedia.org/wiki/", region)),
      data=USpolygons, fill="black", colour="grey"))
```

<!-- paragraph -->

Essayez de cliquer sur un état dans la visualisation de données ci-dessus.
<!-- comment -->
Vous devriez voir la page wikipedia correspondante s'ouvrir dans un nouvel onglet.

<!-- paragraph -->

### Les infobulles utilisant `aes(tooltip)` {#aes-tooltip}

<!-- paragraph -->

Les infobulles sont de petites fenêtres d'information textuelle qui apparaissent lorsque vous survolez un élément à l’écran avec le curseur.
<!-- comment -->
Dans `animint()`, vous pouvez utiliser `aes(tooltip)` pour définir le message spécifique à chaque observation qui s'affichera.
<!-- comment -->
Par exemple, nous l'utilisons pour afficher la population et le nom du pays dans le nuage de points des données de la Banque Mondiale ci-dessous.

<!-- paragraph -->

```{r Ch06-viz-tooltip}
data(WorldBank)
WorldBank1975 <- subset(WorldBank, year == 1975)
animint(
  scatter=ggplot()+
    geom_point(aes(
      x=life.expectancy, y=fertility.rate,
      tooltip=paste(country, "population =", population)),
      size=5,
      data=WorldBank1975))
```

<!-- paragraph -->

Essayez de placer le curseur sur l'un des points de données.
<!-- comment -->
Vous devriez voir apparaître une petite boîte contenant le nom du pays et la population pour ce point de données.

<!-- paragraph -->

Notez qu'une infobulle de la forme "valeur variable" est définie par défaut pour chaque geom avec `aes(clickSelects)`.
<!-- comment -->
Par exemple, un geom avec `aes(clickSelects=année)` affiche l'infobulle par défaut "année 1984" pour une observation à l'année 1984.
<!-- comment -->
Vous pouvez modifier cette valeur par défaut en spécifiant explicitement `aes(tooltip)`.

<!-- paragraph -->

### Attribut HTML id utilisant `aes(id)` {#aes-id}

<!-- paragraph -->

Puisque tout ce qui est tracé par `animint()` est affiché comme un élément [SVG](http://www.w3schools.com/html/html5_svg.asp) dans une page web, vous pourriez vouloir spécifier un élément [attribut HTML id](http://www.w3schools.com/tags/att_global_id.asp) à l'aide de `aes(id)` comme ci-dessous.

<!-- paragraph -->

```{r Ch06-viz-id}
animint(
  map=ggplot()+
    ggtitle("each state/region/group has a unique id")+
    coord_equal()+
    geom_polygon(aes(
      x=long, y=lat, group=group,
      id=gsub(" ", "_", paste(region, group))),
      data=USpolygons, fill="black", colour="grey"))
```

<!-- paragraph -->

Notez comment `gsub` est utilisé pour convertir les espaces en tirets bas (underscores), puisqu'un identifiant bien défini ne doit pas contenir d'espaces.
<!-- comment -->
Notez également que `paste` est utilisé pour ajouter un numéro de groupe, car il peut y avoir plus d'un polygone par état/région, et chaque identifiant doit être unique sur une page web.
<!-- comment -->
Les développeurs d'`animint2` utilisent cette fonctionnalité [pour tester le code de l'afficheur JavaScript de l'animint](https://github.com/tdhock/animint/wiki/Testing) .

<!-- paragraph -->

### Noms de sélecteurs dynamiques basés sur les données en utilisant des `clickSelects` et `showSelected` nommés {#data-driven-selectors}

<!-- paragraph -->

[Chapitre 3](Ch03-showSelected.html#selecting-with-menus) introduit `showSelected` pour désigner un geom qui n'affiche que le sous-ensemble sélectionné de ses données.

<!-- paragraph -->

[Chapitre 4](Ch04-clickSelects.html#clickSelects-keyword) introduit `clickSelects` pour désigner un geom sur lequel on peut cliquer pour modifier une variable de sélection.

<!-- paragraph -->

En général, les noms des sélecteurs sont définis dans `showSelected` ou `clickSelects`.
<!-- comment -->
Par exemple, `showSelected=c("année", "pays")` signifie que deux variables de sélection seront créées (nommées `année` et `pays`).
<!-- comment -->
Cependant, cette méthode devient peu pratique si vous avez de nombreux sélecteurs dans votre visualisation des données.
<!-- comment -->
Pour illustrer, nous considérons l'exemple théorique suivant (le code présenté dans cette section n'est pas directement exécutable).
<!-- comment -->
Supposons que vous souhaitez utiliser 20 noms de variables de sélecteurs différents, `selector1value`...
<!-- comment -->
`selector20value`.
<!-- comment -->
La façon habituelle de définir votre visualisation de données serait la suivante

<!-- paragraph -->

```{r, eval=FALSE}
viz <- list(
  points=ggplot()+
    geom_point(clickSelects="selector1value", data=data1)+
    ...
<!-- comment -->
geom_point(clickSelects="selector20value", data=data20)
)
```

<!-- paragraph -->

Cependant, cette méthode est mauvaise car elle viole le principe DRY (Don't Repeat Yourself).
<!-- comment -->
Une autre façon de procéder serait d'utiliser une boucle `for`:

<!-- paragraph -->

```{r, eval=FALSE}
viz <- list(points=ggplot())
for(selector.name in paste0("selector", 1:20, "value")){
  data.for.selector <- all.data.list[[selector.name]]
<!-- comment -->
viz$points <- viz$points +
    geom_point(clickSelects=selector.name, data=data.for.selector)
}
```

<!-- paragraph -->

Cette méthode est mauvaise car elle est lente pour construire `vis` et la visualisation compilée prend potentiellement beaucoup d'espace disque puisqu'il y a au moins un fichier TSV créé pour chaque `geom_point`.
<!-- comment -->
La méthode préférable est de rajouter des noms dans le vecteur utilisé pour `clickSelects` ou `showSelected`.
<!-- comment -->
Les noms doivent être utilisés pour indiquer la colonne qui contient le nom de la variable du sélecteur.
<!-- comment -->
Par exemple :

<!-- paragraph -->

```{r, eval=FALSE}
viz <- list(
  points=ggplot()+
    geom_point(
      clickSelects=c(selector.name="selector.value"),
      data=all.data)
)
```

<!-- paragraph -->

Le compilateur d'`animint2` parcourt le data.frame `all.data` et crée des sélecteurs pour chacune des valeurs distinctes de `all.data$selector.name`.
<!-- comment -->
En cliquant sur l'un des points de données, le sélecteur correspondant est mis à jour avec la valeur indiquée par `all.data$selector.value`.

<!-- paragraph -->

De la même manière, vous pouvez rajouter des noms au vector `showSelected`, au lieu de créer plusieurs geoms, chacun avec une valeur différente pour `showSelected`.

<!-- paragraph -->

Cette fonctionnalité est utile non seulement pour éviter les répétitions dans la définition de la visualisation des données, mais aussi puisqu'elle est plus efficace sur le plan computationnel.
<!-- comment -->
Pour un exemple détaillé avec des mesures de temps d'exécution et d'espace disque, voir le [chapitre 14](Ch14-PeakSegJoint.html) .

<!-- paragraph -->

## Options du geom {#geom-options}

<!-- paragraph -->

Dans `animint2`, il existe plusieurs options au niveau du geom : `chunk_vars` permet de spécifier comment diviser les ensembles de données pour leur stockage sur disque, et les paramètres `*_off` sont utilisés pour définir comment un geom `clickSelects` devrait être affiché lorsqu'il n'est pas sélectionné.
<!-- comment -->
De plus, les paramètres `help` et `title` peuvent être spécifiés, afin d'ajouter des informations à la visite guidée.

<!-- paragraph -->

### Le paramètre de geom `chunk_vars` {#chunk-vars}

<!-- paragraph -->

Le paramètre `chunk_vars` définit les variables de sélection qui sont utilisées pour diviser l'ensemble de données en morceaux distincts (fichiers TSV) à télécharger.
<!-- comment -->
Un fichier TSV est créé pour chaque combinaison de valeurs des variables `chunk_vars`.
<!-- comment -->
Plus vous spécifiez de variables de sélection dans `chunk_vars`, plus l'ensemble de données sera divisé en différents fichiers TSV, chacun d'une taille plus petite.

<!-- paragraph -->

Le paramètre `chunk_vars` doit être spécifiée comme argument d'une fonction `geom_*`, et sa valeur doit être un vecteur de caractères contenant les noms des variables de sélection.
<!-- comment -->
Lorsque `chunk_vars=character(0)`, soit un vecteur de caractères de longueur zéro, toutes les données sont stockées dans un seul fichier TSV.
<!-- comment -->
A l'autre extreme, lorsque `chunk_vars` contient tous les variables de `showSelected`, un fichier TSV est créé pour chaque combinaison des valeurs de ces variables (beaucoup de fichiers TSV, chacun de petite taille).

<!-- paragraph -->

En général, le compilateur `animint2` choisit une valeur par défaut raisonnable pour `chunk_vars`, mais vous pouvez spécifier `chunk_vars` si la visualisation des données se charge lentement ou occupe trop d'espace sur le disque.
<!-- comment -->
Si la visualisation des données se charge lentement, vous devriez ajouter des variables de sélection à `chunk_vars` afin de réduire la taille du premier fichier TSV à télécharger.
<!-- comment -->
Si la visualisation des données occupe trop d'espace sur le disque, vous pouvez retirer les variables de sélection de `chunk_vars` pour réduire le nombre de fichiers TSV.
<!-- comment -->
De nombreux petits fichiers TSV peuvent occuper plus d'espace disque qu'un seul fichier TSV, car certains systèmes de fichiers stockent une quantité constante de métadonnées pour chaque fichier.

<!-- paragraph -->

Pour illustrer l'utilisation de `chunk_vars`, considérez la visualisation suivante de l'ensemble de données `breakpoints`.

<!-- paragraph -->

![Visualisation des données 'breakpoints'](Ch06-viz-breakpoints.png)

<!-- paragraph -->

L'esquisse ci-dessus est composée de deux graphiques.
<!-- comment -->
Nous commençons par créer le graphique des courbes d'erreur situé à gauche.

<!-- paragraph -->

```{r Ch06-errorPlot}
data(breakpoints)
only.error <- subset(breakpoints$error, type=="E")
only.segments <- subset(only.error,bases.per.probe==bases.per.probe[1])
library(data.table)
fp.fn.names <- rbind(
  data.table(error.type="false positives", type="FP"),
  data.table(error.type="false negatives", type=c("I", "FN")))
error.dt <- data.table(breakpoints$error)
error.type.dt <- error.dt[fp.fn.names, on=list(type)]
<!-- comment -->
fp.fn.dt <- error.type.dt[, list(
  error.value=sum(error)
), by=.(error.type, segments, bases.per.probe)]
<!-- comment -->
errorPlot <- ggplot()+
  ggtitle("select data and segments")+
  theme_bw()+
  geom_tallrect(aes(
    xmin=segments-0.5, xmax=segments+0.5),
    clickSelects="segments",
    data=only.segments,
    alpha=1/2)+
  geom_line(aes(
    segments, error.value, color=error.type,
    group=paste(bases.per.probe, error.type)),
    showSelected="bases.per.probe",
    data=fp.fn.dt,
    size=5)+
  scale_color_manual(values=c(
    "false positives"="red", "false negatives"="blue"))+
  geom_line(aes(
    segments, error, group=bases.per.probe),
    clickSelects="bases.per.probe",
    data=only.error,
    size=4)+
  scale_x_continuous(breaks=c(1, 6, 10, 20))
errorPlot
```

<!-- paragraph -->

Le graphique ci-dessus comprend un `geom_tallrect` avec `clickSelects=segments` et un `geom_line` avec `clickSelects=bases.per.probe`.
<!-- comment -->
Il sera utilisé pour sélectionner les données et le modèle dans le graphique ci-dessous.

<!-- paragraph -->

```{r Ch06-signalPlot}
signalPlot <- ggplot()+
  theme_bw()+
  theme(panel.margin=grid::unit(0, "lines"))+
  theme_animint(height=800)+
  geom_point(aes(
    position/1e5, signal),
    showSelected="bases.per.probe",
    shape=1,
    data=breakpoints$signals)+
  geom_segment(aes(
    first.base/1e5, mean, xend=last.base/1e5, yend=mean),
    showSelected=c("segments", "bases.per.probe"),
    color="green",
    data=breakpoints$segments)
signalPlot+facet_grid(segments ~ bases.per.probe)
```

<!-- paragraph -->

Le graphique non interactif ci-dessus comporte 80 `facets`, un pour chaque combinaison des deux variables `showSelected`, `bases.per.probe` et `segments`.
<!-- comment -->
Nous présentons ci-dessous une version interactive dans laquelle un seul de ces `facets` sera affiché.

<!-- paragraph -->

```{r Ch06-viz-chunk-vars}
(viz.chunk.vars <- animint(
  errorPlot,
  signal=signalPlot+
    geom_vline(aes(
      xintercept=base/1e5),
      showSelected=c("segments", "bases.per.probe"),
      color="green",
      chunk_vars=character(),
      linetype="dashed",
      data=breakpoints$breaks)))
```

<!-- paragraph -->

Cliquez sur le bouton "Afficher le tableau de l'état des téléchargements", et vous devriez voir des décomptes de chunks (fichiers TSV).
<!-- comment -->
Notez que `geom6_vline_signal` n'a qu'un seul morceau, puisque `chunk_vars=character()` est spécifié pour l'élément `geom_vline` dans le code R ci-dessus.
<!-- comment -->
Si une autre valeur de `chunk_vars` était spécifiée, elle créerait un nombre différent de fichiers TSV, mais l'apparence de la viz de données devrait être la même.

<!-- paragraph -->

Ci-dessous, nous utilisons l'option `du` programme en ligne de commande pour déterminer l'utilisation du disque de la viz de données pour différents choix de `chunk_vars`.

<!-- paragraph -->

```{r tsvSizes}
tsvSizes <- function(segment.chunk.vars){
  viz <- list(
    error=errorPlot,
    signal=signalPlot+
      geom_vline(aes(
        xintercept=base/1e5),
        showSelected=c("segments", "bases.per.probe"),
        color="green",
        chunk_vars=segment.chunk.vars,
        linetype="dashed",
        data=breakpoints$breaks)
  )
  info <- animint2dir(viz, open.browser=FALSE)
  cmd <- paste("du -ks", info$out.dir)
  kb.dt <- fread(cmd=cmd)
  setnames(kb.dt, c("kb", "dir"))
  tsv.vec <- Sys.glob(paste0(info$out.dir, "/*.tsv"))
  is.geom6 <- grepl("geom6", tsv.vec)
  data.frame(kb=kb.dt$kb, geom6.tsv=sum(is.geom6), other.tsv=sum(!is.geom6))
}
chunk_vars_list <- list(
  neither=c(),
  bases.per.probe=c("bases.per.probe"),
  segments=c("segments"),
  both=c("segments", "bases.per.probe"))
sizes.list <- lapply(chunk_vars_list, tsvSizes)
(sizes <- do.call(rbind, sizes.list))
```

<!-- paragraph -->

Le tableau de contingence ci-dessus indique le nombre de kilo-octets pour les données, ainsi que le nombre de fichiers TSV pour les éléments suivants `geom6_vline_signal` et les autres geoms.
<!-- comment -->
Notez comment le choix de `chunk_vars` affecte le nombre de fichiers TSV et l'utilisation de l'espace disque.
<!-- comment -->
Depuis `chunk_vars` n'a été spécifié que pour les `geom6_vline_signal` le nombre de fichiers TSV pour les autres geoms ne change pas.
<!-- comment -->
Lorsque les deux `segments` et `bases.per.probe` sont spécifiés pour `chunk_vars` il y a 76 fichiers TSV pour `geom6_vline_signal` et les données prennent `r sizes["both", "kb"]` kilo-octets.
<!-- comment -->
En revanche, `chunk_vars=character()` ne produit qu'un seul fichier TSV pour `geom6_vline_signal` et l'image de données utilise `r sizes["neither", "kb"]` kilo-octets.

<!-- paragraph -->

En conclusion, l'outil de gestion de l'information spécifique au geom `chunk_vars` définit le nombre de fichiers TSV créés pour chaque geom.
<!-- comment -->
Lors du choix de la valeur de l'option `chunk_vars` vous devez tenir compte de l'utilisation du disque et du temps de chargement.
<!-- comment -->
Quelques gros fichiers occupent moins d'espace disque mais sont plus lents à télécharger que de nombreux petits fichiers.

<!-- paragraph -->

### Spécifier le mode d'affichage de l'état de la sélection {#display-selection-state}

<!-- paragraph -->

Animint a des valeurs par défaut raisonnables pour l'affichage de l'état de la sélection.
<!-- comment -->
En particulier,

<!-- paragraph -->

- lorsqu'il y a un rectangle ou une tuile avec clickSelects, nous utilisons la couleur noire/la bordure pour montrer les éléments qui sont sélectionnés, et la couleur transparente pour les éléments qui ne sont pas sélectionnés.
<!-- comment -->
- pour tout autre geom avec clickSelects, nous utilisons l'opacité totale. `alpha` pour afficher les éléments sélectionnés, et `alpha-0.5` pour afficher les éléments qui ne sont pas sélectionnés.

<!-- paragraph -->

Les valeurs par défaut expliquées ci-dessus sont illustrées dans le premier graphique ci-dessous.
<!-- comment -->
Ces valeurs par défaut peuvent être personnalisées en utilisant l'option `alpha_off`, `fill_off` et `color_off` comme dans le code ci-dessous,

<!-- paragraph -->

```{r}
N <- 3
set.seed(1)
demo_df <- data.frame(i=1:N, num=rnorm(N,2))
animint(
  defaults=ggplot()+
    ggtitle("Defaults, no *_off")+
    geom_tile(aes(
      i, 0),
      size=5,
      clickSelects="i",
      data=demo_df)+
    geom_point(aes(
      i, num),
      size=5,
      clickSelects="i",
      data=demo_df),
  off=ggplot()+
    ggtitle("User specified alpha_off, fill_off, color_off")+
    geom_tile(aes(
      i, 0, fill=i),
      clickSelects="i",
      color="red",
      color_off="pink",
      size=5,
      data=demo_df)+
    geom_point(aes(
      i, num),
      size=5,
      alpha=0.5,
      alpha_off=0.1,
      clickSelects="i",
      data=demo_df)+
    geom_point(aes(
      i, -num),
      size=5,
      alpha=1,
      alpha_off=1,
      color="red",
      color_off="black",
      fill="grey",
      fill_off="white",
      clickSelects="i",
      data=demo_df))
```

<!-- paragraph -->

Notez que lorsque vous utilisez l'une de ces propriétés visuelles dans l'élément `aes` ne doit pas être spécifiée en tant que paramètre geom.
<!-- comment -->
Par exemple, dans la tuile ci-dessus, nous avons utilisé `aes(fill)`, donc `fill` et `fill_off` ne doivent pas être spécifiés en tant que paramètres pour ce geom (afin qu'il soit clair que le remplissage est utilisé pour afficher les valeurs des données, et non l'état de la sélection).

<!-- paragraph -->

### Spécifier le texte de la visite guidée {#custom-guided-tour}

<!-- paragraph -->

Depuis janvier 2025, animint prend en charge une visite guidée, qui affiche des informations sur les interactions possibles avec chaque geom.
<!-- comment -->
Pour personnaliser ce qui est affiché pour chaque geom, vous pouvez spécifier l'option `help` et `title` comme dans le code ci-dessous.

<!-- paragraph -->

```{r Ch06-customTour}
animint(
  scatter=ggplot()+
    geom_point(aes(
      x=life.expectancy, y=fertility.rate, color=region),
      size=5,
      showSelected="year",
      clickSelects="country",
      help="One point drawn for each country in the selected year",
      alpha=0.7,
      data=WorldBank)+
    geom_text(aes(
      x=life.expectancy, y=fertility.rate, label=country),
      data=WorldBank,
      title="Selected country",
      showSelected=c("year","country")),
  first=list(
    country="France",
    year=1980))
```

<!-- paragraph -->

Dans le code ci-dessus, nous spécifions `help` pour `geom_point` qui contrôle le sous-texte qui est affiché pour ce geom, après avoir cliqué sur le bouton "Démarrer la visite" au bas de la visualisation de données.
<!-- comment -->
Après avoir cliqué sur le bouton "Suivant", nous pouvons voir l'image suivante `title` qui a été spécifié dans le code, affiché en haut de la fenêtre de visite, pour le `geom_text`.
<!-- comment -->
Ce mécanisme peut être utilisé pour fournir des informations supplémentaires utiles aux utilisateurs de votre visualisation de données, afin qu'ils puissent comprendre plus facilement ce qui est affiché et quelles interactions sont possibles.

<!-- paragraph -->

## Options spécifiques au graphique {#plot-options}

<!-- paragraph -->

Cette section traite des options qui sont spécifiques à un ggplot d'une viz de données.
<!-- comment -->
Les options `theme_animint` est utilisée pour attacher des options animint aux objets ggplot.

<!-- paragraph -->

### Hauteur et largeur du graphique {#plot-height-width}

<!-- paragraph -->

Le `width` et `height` permettent de spécifier les dimensions (en pixels) d'un ggplot affiché par animint.
<!-- comment -->
Par exemple, considérons le remaniement suivant du graphique des États-Unis :

<!-- paragraph -->

```{r Ch06-viz-width-height}
animint(
  map=ggplot()+
    theme_animint(width=750, height=500)+
    theme(
      axis.line=element_blank(),
      axis.text=element_blank(), 
      axis.ticks=element_blank(),
      axis.title=element_blank(),
      panel.border=element_blank(),
      panel.background=element_blank(),
      panel.grid.major=element_blank(),
      panel.grid.minor=element_blank())+
    geom_polygon(aes(
      x=long, y=lat, group=group),
      data=USpolygons, fill="black", colour="grey"))
```

<!-- paragraph -->

Notez que le graphique ci-dessus a été affiché avec une largeur de 750 pixels et une hauteur de 500 pixels, en raison de l'utilisation de la fonction `theme_animint` options.
<!-- comment -->
Si l'une de ces options n'est pas spécifiée pour un ggplot, animint utilise une valeur par défaut de 400 pixels.

<!-- paragraph -->

Notez également que `theme` a été utilisé pour spécifier plusieurs éléments vides.
<!-- comment -->
Cela a pour effet de supprimer les axes et l'arrière-plan, et est généralement utile pour afficher des cartes.

<!-- paragraph -->

### Échelle de taille en pixels {#scale-size-animint}

<!-- paragraph -->

Le `scale_size_animint` doit être utilisée dans tous les ggplots où vous spécifiez `aes(size)`.
<!-- comment -->
Pour comprendre pourquoi, examinons les exemples suivants.

<!-- paragraph -->

```{r Ch06-viz-scale-size}
scatter1975 <- ggplot()+
  geom_point(
    aes(x=life.expectancy, y=fertility.rate, size=population),
    WorldBank1975,
    shape=21,
    color="red",
    fill="black")
(viz.scale.size <- animint(
  ggplotDefault=scatter1975+
    ggtitle("no scale specified"),
  animintDefault=scatter1975+
    ggtitle("scale_size_animint()")+
    scale_size_animint(),
  animintOptions=scatter1975+
    ggtitle("scale_size_animint(pixel.range, breaks)")+
    scale_size_animint(pixel.range=c(5, 15), breaks=10^(10:1))))
```

<!-- paragraph -->

Le premier ggplot ci-dessus n'a pas d'échelle spécifiée, il utilise donc l'échelle ggplot2 par défaut, ce qui pose deux problèmes.
<!-- comment -->
Le premier problème est qu'il semble que tous les pays aient à peu près la même taille, à l'exception des deux pays les plus grands.
<!-- comment -->
Ce problème peut être résolu en ajoutant simplement `scale_size_animint()` au ggplot, ce qui donne le deuxième graphique ci-dessus.
<!-- comment -->
Cependant, un second problème est que les entrées de la légende ne montrent pas toute la plage (ou étendue ou intervalle) des données.
<!-- comment -->
Ce problème est résolu dans le troisième graphique ci-dessus, en spécifiant manuellement l'attribut `breaks` à utiliser pour les entrées de légende.
<!-- comment -->
Notez que l'élément `pixel.range` peut également être utilisé pour spécifier le rayon du plus grand et du plus petit cercle.

<!-- paragraph -->

### Taille du texte des axes et de la légende {#axes-legend-text-size}

<!-- paragraph -->

La syntaxe de définition des axes et de la taille du texte de la légende(en pixels) est quasiment la même que celle de ggplot2.
<!-- comment -->
A l'intérieur `theme` vous pouvez utiliser des nombres directement pour modifier la taille de la police, ou vous pouvez utiliser la fonction `rel()` pour définir la taille relative.

<!-- paragraph -->

```{r Ch06-text-size}
scatter1975 <- ggplot()+
  geom_point(aes(
    x=life.expectancy, y=fertility.rate, color=region),
    data=WorldBank1975)
(viz.text.size <- animint(
  animintDefault=scatter1975+
    theme_animint(width=500, height=500)+
    ggtitle("no axes and legend size specified"),
  animintAxesOptions=scatter1975+
    theme_animint(width=500, height=500)+
    theme(axis.text=element_text(size=20))+
    ggtitle("axis.text=element_text(size=20)"),
  animintLegendOptions=scatter1975+
    theme_animint(width=500, height=500)+
    theme(
      legend.title=element_text(size=24),
      legend.text=element_text(size=rel(2.5)))+
    ggtitle("legend.text=element_text(size=rel(2.5)")))
```

<!-- paragraph -->

Cela permet de modifier la taille de la police tout en modifiant la taille du tracé pour lui donner une plus grande cohérence.

<!-- paragraph -->

Notez que la taille de police par défaut dans animint est de 11px pour les axes et de 16px pour la légende.

<!-- paragraph -->

## Options d'affichage des données globales {#global-options}

<!-- paragraph -->

Les options d'affichage des données globales sont des éléments nommés de l'élément `viz` qui ne sont pas des ggplots.

<!-- paragraph -->

### Révision des options globales introduites précédemment {#review-global}

<!-- paragraph -->

[Chapitre 3](Ch03-showSelected.html#duration-key) a présenté le `duration` pour spécifier la durée des transitions fluides.

<!-- paragraph -->

[Chapitre 3](Ch03-showSelected.html#animation-time) a présenté le `time` pour spécifier une variable de sélection qui est automatiquement mise à jour (animation).

<!-- paragraph -->

[Chapitre 4](Ch04-clickSelects.html#first-option) a présenté le `first` qui permet de spécifier la sélection lorsque l'image de données est affichée pour la première fois.

<!-- paragraph -->

[Chapitre 4](Ch04-clickSelects.html#selector-types-option) a présenté le `selector.types` pour spécifier plusieurs variables de sélection.

<!-- paragraph -->

### Titre de la page web avec l'option title {#title-option}

<!-- paragraph -->

Le `title` doit être une chaîne de caractères, et sera utilisée pour définir l'option `\<title>` de la page web.
<!-- comment -->
Il n'est pas utile d'utiliser l'élément `title` dans un document Rmd tel que cette page.
<!-- comment -->
Un titre peut et doit être utilisé avec `animint2dir` comme dans le code ci-dessous.

<!-- paragraph -->

```{r Ch06-viz-title}
viz.title <- viz.scale.size
viz.title$title <- "Several size scales"
animint2dir(viz.title, "Ch06-title")
```

<!-- paragraph -->

Notez que `viz.scale.size` possède déjà trois ggplots, chacun avec un `ggtitle`.
<!-- comment -->
Ajout de l'élément global `title` a pour effet de définir un titre pour [la page web](Ch06-title/index.html) .

<!-- paragraph -->

Le chapitre 5 a présenté le [animint2pages](Ch05-sharing.html#pages) qui permet de publier un animint sur les pages GitHub.
<!-- comment -->
Il faut que l'animint définisse l'élément `title` car ces méta-données sont nécessaires à l'organisation de l'animint dans une structure [galerie](Ch05-sharing.html#gallery) .

<!-- paragraph -->

### Lier le code R avec l'option source {#source-option}

<!-- paragraph -->

Le `source` doit être une chaîne de caractères : un lien vers le code source R qui a été utilisé pour créer l'animint.

<!-- paragraph -->

```{r Ch06-source-demo}
animint(
  demo=ggplot()+
    geom_point(aes(
      Petal.Length, Sepal.Length),
      data=iris),
  source="https://github.com/tdhock/animint-book/edit/master/Ch06-other.Rmd")
```

<!-- paragraph -->

Notez ci-dessus comment il y a un lien source au bas des données viz.

<!-- paragraph -->

Le chapitre 5 a introduit le [animint2pages](Ch05-sharing.html#pages) qui permet de publier un animint sur les pages GitHub.
<!-- comment -->
Il faut que l'animint définisse l'élément `source` car ces méta-données sont nécessaires à l'organisation de l'animint dans une structure [galerie](Ch05-sharing.html#gallery) .

<!-- paragraph -->

### Lier une vidéo {#video-option}

<!-- paragraph -->

Le `video` doit être une chaîne de caractères : un lien vers une vidéo qui montre des interactions typiques avec l'animint.
<!-- comment -->
Ce mécanisme peut être utilisé pour aider les utilisateurs de votre visualisation de données à comprendre ce qui est affiché, et quelles interactions ils peuvent utiliser.

<!-- paragraph -->

```{r Ch06-link-demo}
animint(
  video="https://vimeo.com/1050117030",
  scatter=ggplot()+
    geom_point(aes(
      x=life.expectancy, y=fertility.rate, color=region),
      clickSelects="country",
      alpha=0.7,
      data=WorldBank1975))
```

<!-- paragraph -->

Dans la visualisation de données ci-dessus, remarquez le lien "vidéo" qui apparaît en bas à droite.
<!-- comment -->
En cliquant sur ce lien, on accède à une vidéo qui a été enregistrée pour expliquer une visualisation de données plus complexe basée sur les données de la Banque mondiale.
<!-- comment -->
L'idée est que vous pouvez enregistrer une vidéo pour chacun de vos animints, puis inclure un lien vers la vidéo à l'aide de ce mécanisme, afin que vos utilisateurs puissent comprendre plus facilement ce qui est affiché, et quelles sont les interactions possibles.

<!-- paragraph -->

### Afficher ou masquer les menus de sélection avec l'option selectize {#selectize-option}

<!-- paragraph -->

L'option selectize doit être une liste nommée de valeurs booléennes.
<!-- comment -->
Les noms doivent être des variables de sélecteur, et les valeurs doivent indiquer si vous souhaitez ou non afficher un menu de sélection via [selectize.js](http://selectize.github.io/selectize.js/) .
<!-- comment -->
Par défaut, animint affiche un menu de sélection pour chaque variable de sélection, à deux exceptions près :

<!-- paragraph -->

- les variables de sélection pilotées par les données qui sont définies à l'aide de l'option [namedclickSelects/showSelectedvariables](Ch06-other.html#data-driven-selectors) .
<!-- comment -->
- les variables de sélection qui ont beaucoup de valeurs (elles sont lentes à afficher).

<!-- paragraph -->

Ces valeurs par défaut devraient convenir à la grande majorité des animints.
<!-- comment -->
Pour ceux qui sont intéressés par un exemple de la façon dont la fonction `selectize` veuillez consulter l'exemple de l'option [PredictedPeaks dans le code source de animint2](https://github.com/tdhock/animint2/blob/master/tests/testthat/test-renderer2-PredictedPeaks.R) .

<!-- paragraph -->

## Résumé du chapitre et exercices {#exercises}

<!-- paragraph -->

Ce chapitre a expliqué plusieurs options de personnalisation des animints au niveau de l'observation, du geom, du graphique et du global.

<!-- paragraph -->

Exercices :

<!-- paragraph -->

- Créez d'autres versions de `viz.chunk.vars` avec différentes valeurs de `chunk_vars` pour les `geom_point` et `geom_segment`.
<!-- comment -->
Comment le choix des `chunk_vars` affecte-t-il l'apparence de la visualisation ?
<!-- comment -->
L'espace disque ?
<!-- comment -->
Le temps de chargement ?

<!-- paragraph -->

Suivant, [Chapitre 7](Ch07-limitations.html) explique les limites de l'implémentation actuelle de animint2.

<!-- paragraph -->


