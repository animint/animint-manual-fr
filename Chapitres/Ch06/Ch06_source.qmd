---
title: Animint options
layout: default
output: bookdown::html_chapter
---

Traduction de l'[anglais](https://github.com/tdhock/animint-book/)
[Ch06-other](https://raw.githubusercontent.com/tdhock/animint-book/master/Ch06-other.Rmd)

<!-- paragraph -->

# Chapitre 6, Options Animint

<!-- paragraph -->

```{r}
#| echo: false
knitr::opts_chunk$set(fig.path="Ch06-figures/")
```

<!-- paragraph -->

Ce chapitre donne une liste complète des nouvelles fonctionnalités qu'`animint2` introduit dans la grammaire des graphiques.
<!-- comment -->
Après avoir lu ce chapitre, vous comprendrez comment personnaliser vos graphiques `animint2` via

<!-- paragraph -->

- les `aes()` `href`, `tooltip` et `id` pour les caractéristiques propres à l'observation ;
<!-- comment -->
- les éléments nommés de `clickSelects` et `showSelected` pour spécifier plusieurs variables de sélection à la fois ;
<!-- comment -->
- l'option `chunk_vars` spécifique au geom ;
<!-- comment -->
- les paramètres de geom `color_off`, `fill_off`, et `alpha_off` pour spécifier comment l'état de la sélection est affiché;
<!-- comment -->
- les paramètres de geom `help` et `title`, texte qui est affiché dans la visite guidée.
<!-- comment -->
- les légendes et les options de hauteur/largeur propres au graphique
<!-- comment -->
- les options globales.

<!-- paragraph -->

## Options spécifiques à l'observation (nouveaux `aes()`) {#new-aesthetics}

<!-- paragraph -->

Cette section explique les nouveaux `aes()` reconnus par `animint2`.

<!-- paragraph -->

### Revue des `aes()` introduits précédemment {#review-aesthetics}

<!-- paragraph -->

Nous allons commencer par discuter des nouveaux `aes()` que nous avons déjà introduits dans les chapitres précédents.

<!-- paragraph -->

[Chapitre 3](Ch03-showSelected.html#duration-key) a également introduit `aes(key)` afin de désigner une variable à utiliser pour des transitions fluides et interprétables.

<!-- paragraph -->

### Hyperliens utilisant `aes(href)` {#aes-href}

<!-- paragraph -->

Le code ci-dessous utilise `animint()` pour tracer une carte des États-Unis.

<!-- paragraph -->

```{r Ch06-viz-href}
library(animint2)
USpolygons <- map_data("state")
animint(
  map=ggplot()+
    ggtitle("cliquez sur un state pour lire sa page Wikipedia")+
    coord_equal()+
    geom_polygon(aes(
      x=long, y=lat, group=group,
      href=paste0("http://fr.wikipedia.org/wiki/", region)),
      data=USpolygons, fill="black", colour="grey"))
```

<!-- paragraph -->

Essayez de cliquer sur un état dans la visualisation de données ci-dessus.
<!-- comment -->
Vous devriez voir la page wikipedia correspondante s'ouvrir dans un nouvel onglet.

<!-- paragraph -->

### Les infobulles utilisant `aes(tooltip)` {#aes-tooltip}

<!-- paragraph -->

Les infobulles sont de petites fenêtres d'information textuelle qui apparaissent lorsque vous survolez un élément à l’écran avec le curseur.
<!-- comment -->
Dans `animint()`, vous pouvez utiliser `aes(tooltip)` pour définir le message spécifique à chaque observation qui s'affichera.
<!-- comment -->
Par exemple, nous l'utilisons pour afficher la population et le nom du pays dans le nuage de points des données de la Banque mondiale ci-dessous.

<!-- paragraph -->

```{r Ch06-viz-tooltip}
data(BanqueMondiale, package="animint2fr")
BanqueMondiale1975 <- subset(BanqueMondiale, année == 1975)
animint(
  scatter=ggplot()+
    geom_point(aes(
      x=espérance.de.vie, y=taux.de.fertilité,
      tooltip=paste(pays, "population =", population)),
      size=5,
      data=BanqueMondiale1975))
```

<!-- paragraph -->

Placez le curseur sur l'un des points de données.
<!-- comment -->
Vous devriez voir apparaître une petite boîte contenant le nom du pays et la population pour ce point de données.

<!-- paragraph -->

Notez qu'une infobulle de la forme "valeur variable" est définie par défaut pour chaque geom avec `aes(clickSelects)`.
<!-- comment -->
Par exemple, un geom avec `aes(clickSelects=année)` affiche l'infobulle par défaut "année 1984" pour une observation à l'année 1984.
<!-- comment -->
Vous pouvez modifier cette valeur par défaut en spécifiant explicitement `aes(tooltip)`.

<!-- paragraph -->

### Attribut HTML id utilisant `aes(id)` {#aes-id}

<!-- paragraph -->

Puisque tout ce qui est tracé par `animint()` est affiché comme un élément [SVG](http://www.w3schools.com/html/html5_svg.asp) dans une page web, vous pourriez vouloir spécifier un élément [attribut HTML id](http://www.w3schools.com/tags/att_global_id.asp) à l'aide de `aes(id)` comme ci-dessous.

<!-- paragraph -->

```{r Ch06-viz-id}
animint(
  map=ggplot()+
    ggtitle("chaque state/région/groupe a un id unique")+
    coord_equal()+
    geom_polygon(aes(
      x=long, y=lat, group=group,
      id=gsub(" ", "_", paste(region, group))),
      data=USpolygons, fill="black", colour="grey"))
```

<!-- paragraph -->

Notez que pour qu'un identifiant soit bien défini il ne doit pas contenir d'espaces, nous utilisons donc `gsub` pour convertir les espaces en tirets bas (underscores).
<!-- comment -->
Notez également que `paste` est utilisé pour ajouter un numéro de groupe, car il peut y avoir plus d'un polygone par état/région, et chaque identifiant doit être unique sur une page web.
<!-- comment -->
Les développeurs d'`animint2` utilisent cette fonctionnalité [pour tester le code de l'afficheur JavaScript de l'animint](https://github.com/tdhock/animint/wiki/Testing) .

<!-- paragraph -->

### Noms de sélecteurs dynamiques basés sur les données en utilisant des `clickSelects` et `showSelected` nommés {#data-driven-selectors}

<!-- paragraph -->

[Chapitre 3](Ch03-showSelected.html#selecting-with-menus) introduit `showSelected` pour désigner un geom qui n'affiche que le sous-ensemble sélectionné de ses données.

<!-- paragraph -->

[Chapitre 4](Ch04-clickSelects.html#clickSelects-keyword) introduit `clickSelects` pour désigner un geom sur lequel on peut cliquer pour modifier une variable de sélection.

<!-- paragraph -->

En général, les noms de sélecteurs sont définis dans `showSelected` ou `clickSelects`.
<!-- comment -->
Par exemple, `showSelected=c("année", "pays")` signifie que deux variables de sélection seront créées (nommées `année` et `pays`).
<!-- comment -->
Cependant, cette méthode devient peu pratique si vous avez de nombreux sélecteurs dans votre visualisation des données.
<!-- comment -->
Considérons par exemple le cas théorique suivant (le code présenté dans cette section n'est pas directement exécutable).
<!-- comment -->
Supposons que vous souhaitez utiliser 20 noms de variables de sélecteurs différents, `selector1value`...
<!-- comment -->
`selector20value`.
<!-- comment -->
La façon habituelle de définir votre visualisation de données serait la suivante

<!-- paragraph -->

```{r, eval=FALSE}
vis <- list(
  points=ggplot()+
    geom_point(clickSelects="selector1value", data=data1)+
    ...
<!-- comment -->
geom_point(clickSelects="selector20value", data=data20)
)
```

<!-- paragraph -->

Cependant, cette méthode est mauvaise car elle viole le principe DRY (Don't Repeat Yourself).
<!-- comment -->
Une autre façon de procéder serait d'utiliser une boucle `for`:

<!-- paragraph -->

```{r, eval=FALSE}
vis <- list(points=ggplot())
for(selector.name in paste0("selector", 1:20, "value")){
  data.for.selector <- all.data.list[[selector.name]]
<!-- comment -->
vis$points <- vis$points +
    geom_point(clickSelects=selector.name, data=data.for.selector)
}
```

<!-- paragraph -->

Cette méthode est mauvaise car elle est lente pour construire `vis` et la visualisation compilée prend potentiellement beaucoup d'espace disque puisqu'il y a au moins un fichier TSV créé pour chaque `geom_point`.
<!-- comment -->
La méthode à privilégier est de rajouter des noms dans le vecteur utilisé pour `clickSelects` ou `showSelected`.
<!-- comment -->
Les noms doivent être utilisés pour indiquer la colonne qui contient le nom de la variable du sélecteur.
<!-- comment -->
Par exemple :

<!-- paragraph -->

```{r, eval=FALSE}
vis <- list(
  points=ggplot()+
    geom_point(
      clickSelects=c(selector.name="selector.value"),
      data=all.data)
)
```

<!-- paragraph -->

Le compilateur d'`animint2` parcourt le data.frame `all.data` et crée des sélecteurs pour chacune des valeurs distinctes de `all.data$selector.name`.
<!-- comment -->
Lorsqu'on clique sur l'un des points de données, le sélecteur correspondant est mis à jour avec la valeur indiquée par `all.data$selector.value`.

<!-- paragraph -->

De la même manière, vous pouvez rajouter des noms au vecteur `showSelected`, au lieu de créer plusieurs geoms, ayant une valeur différente pour `showSelected`.

<!-- paragraph -->

Cette fonctionnalité évite non seulement les répétitions dans la définition de la visualisation des données, mais elle augmente aussi l'efficacité sur le plan computationnel.
<!-- comment -->
Pour un exemple détaillé avec des mesures de temps d'exécution et d'espace disque, voir le [chapitre 14](Ch14-PeakSegJoint.html) .

<!-- paragraph -->

## Options du geom {#geom-options}

<!-- paragraph -->

Dans `animint2`, il existe plusieurs options de personalisation pour les geoms. Par exemple, `chunk_vars` permet de spécifier la division des ensembles de données pour leur stockage sur disque. Quant aux paramètres `*_off`, ils sont utilisés pour définir l'affichage d'un geom `clickSelects` lorsqu'il n'est pas sélectionné.
<!-- comment -->
De plus, les paramètres `help` et `title` peuvent être définis, pour ajouter des informations à la visite guidée.

<!-- paragraph -->

### Le paramètre de geom `chunk_vars` {#chunk-vars}

<!-- paragraph -->

Le paramètre `chunk_vars` définit les variables de sélection qui sont utilisées pour diviser l'ensemble de données en morceaux distincts (fichiers TSV) à télécharger.
<!-- comment -->
Un fichier TSV est créé pour chaque combinaison de valeurs des variables `chunk_vars`.
<!-- comment -->
Plus le nombre de variables de sélection spécifiées dans `chunk_vars` est élevé, plus l'ensemble de données sera divisé en fichiers TSV distincts, chacun ayant une taille plus petite.

<!-- paragraph -->

L'option `chunk_vars` doit être spécifiée comme argument d'une fonction `geom_*`, et sa valeur doit être un vecteur de caractères contenant le nom des variables de sélection.
<!-- comment -->
Lorsque `chunk_vars=character(0)`, soit un vecteur de caractères de longueur zéro, toutes les données sont stockées dans un seul fichier TSV.
<!-- comment -->
À l'autre extrême, lorsque `chunk_vars` contient toutes les variables de `showSelected`, un fichier TSV est créé pour chaque combinaison des valeurs de ces variables (beaucoup de fichiers TSV, chacun de petite taille).

<!-- paragraph -->

En général, le compilateur `animint2` choisit une valeur par défaut raisonnable pour `chunk_vars`, mais vous pouvez spécifier `chunk_vars` si la visualisation des données se charge lentement ou occupe trop d'espace sur le disque.
<!-- comment -->
Si la visualisation des données se charge lentement, vous devriez ajouter des variables de sélection à `chunk_vars` afin de réduire la taille du premier fichier TSV à télécharger.
<!-- comment -->
Si la visualisation des données occupe trop d'espace sur le disque, vous pouvez retirer les variables de sélection de `chunk_vars` pour réduire le nombre de fichiers TSV.
<!-- comment -->
De nombreux petits fichiers TSV peuvent occuper plus d'espace disque qu'un seul fichier TSV, car certains systèmes de fichiers stockent une quantité constante de métadonnées pour chaque fichier.

<!-- paragraph -->

Pour illustrer l'utilisation de `chunk_vars`, considérez la visualisation suivante de l'ensemble de données `breakpoints`.

<!-- paragraph -->

![Visualisation des données 'breakpoints'](Ch06-viz-breakpoints.png)

<!-- paragraph -->

L'esquisse ci-dessus est composée de deux graphiques.
<!-- comment -->
Nous commençons par créer le graphique des courbes d'erreurs situé à gauche.

<!-- paragraph -->

```{r Ch06-viz-errorPlot}
data(breakpoints)
only.error <- subset(breakpoints$error, type=="E")
only.segments <- subset(only.error,bases.per.probe==bases.per.probe[1])
library(data.table)
fp.fn.names <- rbind(
  data.table(error.type="false positives", type="FP"),
  data.table(error.type="false negatives", type=c("I", "FN")))
error.dt <- data.table(breakpoints$error)
error.type.dt <- error.dt[fp.fn.names, on=list(type)]
fp.fn.dt <- error.type.dt[, list(
  error.value=sum(error)
), by=.(error.type, segments, bases.per.probe)]
errorPlot <- ggplot()+
  ggtitle("selectionner les données et les segments")+
  theme_bw()+
  geom_tallrect(aes(
    xmin=segments-0.5, xmax=segments+0.5),
    clickSelects="segments",
    data=only.segments,
    alpha=1/2)+
  geom_line(aes(
    segments, error.value, color=error.type,
    group=paste(bases.per.probe, error.type)),
    showSelected="bases.per.probe",
    data=fp.fn.dt,
    size=5)+
  scale_color_manual(values=c(
    "false positives"="red", "false negatives"="blue"))+
  geom_line(aes(
    segments, error, group=bases.per.probe),
    clickSelects="bases.per.probe",
    data=only.error,
    size=4)+
  scale_x_continuous(breaks=c(1, 6, 10, 20))
errorPlot
```

<!-- paragraph -->

Le graphique ci-dessus comprend un `geom_tallrect` avec `clickSelects=segments` et un `geom_line` avec `clickSelects=bases.per.probe`.
<!-- comment -->
Il sera utilisé pour sélectionner les données et le modèle dans le graphique ci-dessous.

<!-- paragraph -->

```{r Ch06-viz-signalPlot}
signalPlot <- ggplot()+
  theme_bw()+
  theme(panel.margin=grid::unit(0, "lines"))+
  theme_animint(height=800)+
  geom_point(aes(
    position/1e5, signal),
    showSelected="bases.per.probe",
    shape=1,
    data=breakpoints$signals)+
  geom_segment(aes(
    first.base/1e5, mean, xend=last.base/1e5, yend=mean),
    showSelected=c("segments", "bases.per.probe"),
    color="green",
    data=breakpoints$segments)
signalPlot+facet_grid(segments ~ bases.per.probe)
```

<!-- paragraph -->

Le graphique non interactif ci-dessus comporte 80 `facets`, un pour chaque combinaison des deux variables `showSelected`, c'est-à dire `bases.per.probe` et `segments`.
<!-- comment -->
Nous présentons ci-dessous une version interactive dans laquelle un seul de ces `facets` sera affiché.

<!-- paragraph -->

```{r Ch06-viz-chunk-vars}
(viz.chunk.vars <- animint(
  errorPlot,
  signal=signalPlot+
    geom_vline(aes(
      xintercept=base/1e5),
      showSelected=c("segments", "bases.per.probe"),
      color="green",
      chunk_vars=character(),
      linetype="dashed",
      data=breakpoints$breaks)))
```

<!-- paragraph -->

Cliquez sur le bouton "Afficher le tableau de l'état des téléchargements", et vous devriez voir des décomptes de chunks (fichiers TSV).
<!-- comment -->
Notez que `geom6_vline_signal` n'a qu'un seul morceau, puisque `chunk_vars=character()` est spécifié pour l'élément `geom_vline` dans le code R ci-dessus.
<!-- comment -->
Si une autre valeur de `chunk_vars` était spécifiée, cela créerait un nombre différent de fichiers TSV, mais l'apparence de la vvisualisation de données devrait être la même.

<!-- paragraph -->

Ci-dessous, nous utilisons le programme en ligne de commande `du` pour déterminer l'utilisation du disque de la visualisation de données pour différents choix de `chunk_vars`.

<!-- paragraph -->

```{r}
tsvSizes <- function(segment.chunk.vars){
  vis <- list(
    error=errorPlot,
    signal=signalPlot+
      geom_vline(aes(
        xintercept=base/1e5),
        showSelected=c("segments", "bases.per.probe"),
        color="green",
        chunk_vars=segment.chunk.vars,
        linetype="dashed",
        data=breakpoints$breaks)
  )
  info <- animint2dir(vis, open.browser=FALSE)
  cmd <- paste("du -ks", info$out.dir)
  kb.dt <- fread(cmd=cmd)
  setnames(kb.dt, c("kb", "dir"))
  tsv.vec <- Sys.glob(paste0(info$out.dir, "/*.tsv"))
  is.geom6 <- grepl("geom6", tsv.vec)
  data.frame(
    kb=kb.dt$kb, geom6.tsv=sum(is.geom6), other.tsv=sum(!is.geom6))
}
chunk_vars_list <- list(
  neither=c(),
  bases.per.probe=c("bases.per.probe"),
  segments=c("segments"),
  both=c("segments", "bases.per.probe"))
sizes.list <- lapply(chunk_vars_list, tsvSizes)
(sizes <- do.call(rbind, sizes.list))
```

<!-- paragraph -->

Le tableau ci-dessus indique le nombre de kilo-octets pour la visualisation des données, ainsi que le nombre de fichiers TSV pour `geom6_vline_signal` et les autres geoms.
<!-- comment -->
Notez comment le choix de `chunk_vars` affecte le nombre de fichiers TSV et l'utilisation de l'espace disque.
<!-- comment -->
Depuis `chunk_vars` n'a été spécifié que pour les `geom6_vline_signal` le nombre de fichiers TSV pour les autres geoms ne change pas.
<!-- comment -->
Lorsque `segments` et `bases.per.probe` sont tous les deux spécifiés pour `chunk_vars`, il y a 76 fichiers TSV pour `geom6_vline_signal`, et la visualisation des données occupe `r sizes["both", "kb"]` kilo-octets.
<!-- comment -->
En revanche, `chunk_vars=character()` ne produit qu'un seul fichier TSV pour `geom6_vline_signal`, et la visualisation des données occupe `r sizes["neither", "kb"]` kilo-octets.

<!-- paragraph -->

En conclusion, l'option spécifique au geom `chunk_vars` détermine le nombre de fichiers TSV créés pour chaque geom.
<!-- comment -->
Lors du choix de la valeur de l'option `chunk_vars` vous devez tenir compte de l'utilisation du disque et du temps de chargement.
<!-- comment -->
Un petit nombre de gros fichiers occupent moins d'espace disque, mais sont plus lents à télécharger que de nombreux petits fichiers.

<!-- paragraph -->

### Préciser le mode d'affichage de l'état de la sélection {#display-selection-state}

<!-- paragraph -->

`Animint2` a des valeurs par défaut raisonnables pour l'affichage de l'état de sélection.
<!-- comment -->
En particulier,

<!-- paragraph -->

- lorsqu'il y a un `rect` ou un `tile` avec `clickSelects`, nous utilisons le noir pour `color/border` pour montrer les éléments qui sont sélectionnés, et le transparent pour les éléments qui ne sont pas sélectionnés.
<!-- comment -->
- pour tout autre geom avec `clickSelects`, nous utilisons une opacité complète `alpha` pour afficher les éléments sélectionnés, et une opacité réduite `alpha-0.5` pour les éléments non sélectionnés.

<!-- paragraph -->

Les valeurs par défaut expliquées ci-dessus sont illustrées dans le premier graphique ci-dessous.
<!-- comment -->
Ces valeurs par défaut peuvent être personnalisées en utilisant les paramètres du geom `alpha_off`, `fill_off` et `color_off` comme dans le code ci-dessous,

<!-- paragraph -->

```{r Ch06-viz-off}
N <- 3
set.seed(1)
demo_df <- data.frame(i=1:N, num=rnorm(N,2))
animint(
  defaults=ggplot()+
    ggtitle("Paramètres par défaut, sans *_off")+
    geom_tile(aes(
      i, 0),
      size=5,
      clickSelects="i",
      data=demo_df)+
    geom_point(aes(
      i, num),
      size=5,
      clickSelects="i",
      data=demo_df),
  off=ggplot()+
    ggtitle("Paramètres définis par l'utilisateur  : alpha_off, fill_off, color_off")+
    geom_tile(aes(
      i, 0, fill=i),
      clickSelects="i",
      color="red",
      color_off="pink",
      size=5,
      data=demo_df)+
    geom_point(aes(
      i, num),
      size=5,
      alpha=0.5,
      alpha_off=0.1,
      clickSelects="i",
      data=demo_df)+
    geom_point(aes(
      i, -num),
      size=5,
      alpha=1,
      alpha_off=1,
      color="red",
      color_off="black",
      fill="grey",
      fill_off="white",
      clickSelects="i",
      data=demo_df))
```

<!-- paragraph -->

Notez que lorsque vous utilisez l'une de ces propriétés visuelles dans le mapping `aes`, elle ne doit pas être spécifiée en tant que paramètre geom.
<!-- comment -->
Par exemple, dans le tile ci-dessus, nous avons utilisé `aes(fill)`, donc `fill` et `fill_off` ne doivent pas être spécifiés en tant que paramètres pour ce geom (afin qu'il soit clair que `fill` est utilisé pour afficher les valeurs des données, et non l'état de sélection).

<!-- paragraph -->

### Spécification du texte de la visite guidée {#custom-guided-tour}

<!-- paragraph -->

Depuis janvier 2025, `animint2` prend en charge une visite guidée, qui affiche des informations sur les interactions possibles avec chaque geom.
<!-- comment -->
Pour personnaliser ce qui est affiché pour chaque geom, vous pouvez spécifier les paramètres `help` et `title`, comme dans le code ci-dessous.

<!-- paragraph -->

```{r Ch06-viz-customTour}
animint(
  scatter=ggplot()+
    geom_point(aes(
      x=espérance.de.vie, y=taux.de.fertilité, color=région),
      size=5,
      showSelected="année",
      clickSelects="pays",
      help="Un point est tracé pour chaque pays dans l'année sélectionnée",
      alpha=0.7,
      data=BanqueMondiale)+
    geom_text(aes(
      x=espérance.de.vie, y=taux.de.fertilité, label=pays),
      data=BanqueMondiale,
      title="Pays sélectionné",
      showSelected=c("année","pays")),
  first=list(
    pays="France",
    année=1980))
```

<!-- paragraph -->

Dans le code ci-dessus, nous spécifions `help` pour `geom_point`, qui contrôle le sous-texte pour ce geom après avoir cliqué sur le bouton "Start Tour" au bas de la visualisation de données.
<!-- comment -->
Après avoir cliqué sur le bouton "Next", nous pouvons voir le `title` qui a été spécifié dans le code, affiché en haut de la fenêtre de visite, pour le `geom_text`.
<!-- comment -->
Ce mécanisme peut être utilisé pour fournir des informations supplémentaires utiles aux utilisateurs de votre visualisation de données, afin qu'ils puissent comprendre plus facilement ce qui est affiché et quelles interactions sont possibles.

<!-- paragraph -->

## Options spécifiques au graphique {#plot-options}

<!-- paragraph -->

Cette section traite des options qui sont spécifiques à un ggplot d'une visualisation de données.
<!-- comment -->
La fonction `theme_animint` est utilisée pour attacher des options `animint2` aux objets ggplot.

<!-- paragraph -->

### Hauteur et largeur du graphique {#plot-height-width}

<!-- paragraph -->

Les options `width` et `height` permettent de spécifier les dimensions (en pixels) d'un ggplot affiché par `animint()`.
<!-- comment -->
Par exemple, considérons le remaniement suivant du graphique des États-Unis :

<!-- paragraph -->

```{r Ch06-viz-width-height}
animint(
  map=ggplot()+
    theme_animint(width=750, height=500)+
    theme(
      axis.line=element_blank(),
      axis.text=element_blank(), 
      axis.ticks=element_blank(),
      axis.title=element_blank(),
      panel.border=element_blank(),
      panel.background=element_blank(),
      panel.grid.major=element_blank(),
      panel.grid.minor=element_blank())+
    geom_polygon(aes(
      x=long, y=lat, group=group),
      data=USpolygons, fill="black", colour="grey"))
```

<!-- paragraph -->

Notez que le graphique ci-dessus a été généré avec une largeur de 750 pixels et une hauteur de 500 pixels, en raison des options `theme_animint`.
<!-- comment -->
Si l'une de ces options n'est pas définie pour un ggplot, `animint()` utilise une valeur par défaut de 400 pixels.

<!-- paragraph -->

Notez également que `theme` a été utilisé pour spécifier plusieurs éléments vides.
<!-- comment -->
Cela a pour effet de supprimer les axes et l'arrière-plan, et est généralement utile pour générer des cartes.

<!-- paragraph -->

### Échelle de taille en pixels {#scale-size-animint}

<!-- paragraph -->

L'échelle `scale_size_animint` doit être utilisée dans tous les ggplots où vous précisez `aes(size)`.
<!-- comment -->
Pour comprendre pourquoi, consultez les exemples suivants.

<!-- paragraph -->

```{r Ch06-viz-scale-size}
nuage1975 <- ggplot()+
  geom_point(
    aes(x=espérance.de.vie, y=taux.de.fertilité, size=population),
    BanqueMondiale1975,
    shape=21,
    color="red",
    fill="black")
(viz.scale.size <- animint(
  ggplotDefault=nuage1975+
    ggtitle("Aucune échelle spécifiée"),
  animintDefault=nuage1975+
    ggtitle("scale_size_animint()")+
    scale_size_animint(),
  animintOptions=nuage1975+
    ggtitle("scale_size_animint(pixel.range, breaks)")+
    scale_size_animint(pixel.range=c(5, 15), breaks=10^(10:1))))
```

<!-- paragraph -->

Le premier ggplot ci-dessus n'a pas d'échelle définie, il utilise donc l'échelle par défaut de ggplot2, posant ainsi deux problèmes.
<!-- comment -->
Le premier problème est qu'il semble que tous les pays aient à peu près la même taille, à l'exception des deux plus grands pays.
<!-- comment -->
Ce problème peut être résolu en ajoutant simplement `scale_size_animint()` au ggplot, ce qui donne le deuxième graphique ci-dessus.
<!-- comment -->
Cependant, un second problème est que les entrées de la légende ne montrent pas toute l'étendue des données.
<!-- comment -->
Ce problème est résolu dans le troisième graphique ci-dessus, en spécifiant manuellement l'option `breaks` à utiliser pour les entrées de légende.
<!-- comment -->
Notez que l'argument `pixel.range` peut également être utilisé pour définir le rayon du plus grand et du plus petit cercle.

<!-- paragraph -->

### Taille du texte des axes et de la légende {#axes-legend-text-size}

<!-- paragraph -->

La syntaxe de définition des axes et de la taille du texte de la légende(en pixels) est quasiment la même que celle de ggplot2.
<!-- comment -->
A l'intérieur `theme` vous pouvez utiliser des nombres directement pour modifier la taille de la police, ou vous pouvez utiliser la fonction `rel()` pour définir la taille relative.

<!-- paragraph -->

```{r Ch06-viz-text-size}
nuage1975 <- ggplot()+
  geom_point(aes(
    x=espérance.de.vie, y=taux.de.fertilité, color=région),
    data=BanqueMondiale1975)
(viz.text.size <- animint(
  animintDefault=nuage1975+
    theme_animint(width=500, height=500)+
    ggtitle("Aucun axe ni taille de légende spécifiés"),
  animintAxesOptions=nuage1975+
    theme_animint(width=500, height=500)+
    theme(axis.text=element_text(size=20))+
    ggtitle("axis.text=element_text(size=20)"),
  animintLegendOptions=nuage1975+
    theme_animint(width=500, height=500)+
    theme(
      legend.title=element_text(size=24),
      legend.text=element_text(size=rel(2.5)))+
    ggtitle("legend.text=element_text(size=rel(2.5)")))
```

<!-- paragraph -->

Cela permet de modifier la taille de la police tout en modifiant la taille du tracé pour lui donner une plus grande cohérence.

<!-- paragraph -->

Notez que la taille de police par défaut dans animint est de 11px pour les axes et de 16px pour la légende.

<!-- paragraph -->

## Options d'affichage des données globales {#global-options}

<!-- paragraph -->

Les options d'affichage des données globales sont des éléments nommés de l'élément `viz` qui ne sont pas des ggplots.

<!-- paragraph -->

### Révision des options globales introduites précédemment {#review-global}

<!-- paragraph -->

[Chapitre 3](Ch03-showSelected.html#duration-key) a présenté le `duration` pour spécifier la durée des transitions fluides.

<!-- paragraph -->

[Chapitre 3](Ch03-showSelected.html#animation-time) a présenté le `time` pour spécifier une variable de sélection qui est automatiquement mise à jour (animation).

<!-- paragraph -->

[Chapitre 4](Ch04-clickSelects.html#first-option) a présenté le `first` qui permet de spécifier la sélection lorsque l'image de données est affichée pour la première fois.

<!-- paragraph -->

[Chapitre 4](Ch04-clickSelects.html#selector-types-option) a présenté le `selector.types` pour spécifier plusieurs variables de sélection.

<!-- paragraph -->

### Titre de la page web avec l'option title {#title-option}

<!-- paragraph -->

Le `title` doit être une chaîne de caractères, et sera utilisée pour définir l'option `\<title>` de la page web.
<!-- comment -->
Il n'est pas utile d'utiliser l'élément `title` dans un document Rmd tel que cette page.
<!-- comment -->
Un titre peut et doit être utilisé avec `animint2dir` comme dans le code ci-dessous.

<!-- paragraph -->

```{r}
vis.title <- viz.scale.size
vis.title$title <- "Plusieurs échelles de taille"
animint2dir(vis.title, "Ch06-viz-title")
```

<!-- paragraph -->

Notez que `viz.scale.size` possède déjà trois ggplots, chacun avec un `ggtitle`.
<!-- comment -->
Ajout de l'option global `title` a pour effet de définir un titre pour [la page web](Ch06-title/index.html) .

<!-- paragraph -->

Le chapitre 5 a présenté le [animint2pages](Ch05-sharing.html#pages) qui permet de publier un animint sur les pages GitHub.
<!-- comment -->
Il faut que l'animint définisse l'élément `title` car ces méta-données sont nécessaires à l'organisation de l'animint dans une structure [galerie](Ch05-sharing.html#gallery) .

<!-- paragraph -->

### Lier le code R avec l'option source {#source-option}

<!-- paragraph -->

Le `source` doit être une chaîne de caractères : un lien vers le code source R qui a été utilisé pour créer l'animint.

<!-- paragraph -->

```{r Ch06-viz-source-demo}
animint(
  demo=ggplot()+
    geom_point(aes(
      Petal.Length, Sepal.Length),
      data=iris),
  source=paste0(
    "https://github.com/animint/animint-manual-fr",
    "/blob/main/Chapitres/Ch06/Ch06_source.Rmd"))
```

<!-- paragraph -->

Notez ci-dessus comment il y a un lien source au bas des données viz.

<!-- paragraph -->

Le chapitre 5 a introduit le [animint2pages](Ch05-sharing.html#pages) qui permet de publier un animint sur les pages GitHub.
<!-- comment -->
Il faut que l'animint définisse l'élément `source` car ces méta-données sont nécessaires à l'organisation de l'animint dans une structure [galerie](Ch05-sharing.html#gallery) .

<!-- paragraph -->

### Lier une vidéo {#video-option}

<!-- paragraph -->

Le `video` doit être une chaîne de caractères : un lien vers une vidéo qui montre des interactions typiques avec l'animint.
<!-- comment -->
Ce mécanisme peut être utilisé pour aider les utilisateurs de votre visualisation de données à comprendre ce qui est affiché, et quelles interactions ils peuvent utiliser.

<!-- paragraph -->

```{r Ch06-viz-link-demo}
animint(
  video="https://vimeo.com/1050117030",
  scatter=ggplot()+
    geom_point(aes(
      x=espérance.de.vie, y=taux.de.fertilité, color=région),
      clickSelects="pays",
      alpha=0.7,
      data=BanqueMondiale1975))
```

<!-- paragraph -->

Dans la visualisation de données ci-dessus, remarquez le lien "vidéo" qui apparaît en bas à droite.
<!-- comment -->
En cliquant sur ce lien, on accède à une vidéo qui a été enregistrée pour expliquer une visualisation de données plus complexe basée sur les données de la Banque mondiale.
<!-- comment -->
L'idée est que vous pouvez enregistrer une vidéo pour chacun de vos animints, puis inclure un lien vers la vidéo à l'aide de ce mécanisme, afin que vos utilisateurs puissent comprendre plus facilement ce qui est affiché, et quelles sont les interactions possibles.

<!-- paragraph -->

### Afficher ou masquer les menus de sélection avec l'option selectize {#selectize-option}

<!-- paragraph -->

L'option selectize doit être une liste nommée de valeurs booléennes.
<!-- comment -->
Les noms doivent être des variables de sélecteur, et les valeurs doivent indiquer si vous souhaitez ou non afficher un menu de sélection via [selectize.js](http://selectize.github.io/selectize.js/) .
<!-- comment -->
Par défaut, animint affiche un menu de sélection pour chaque variable de sélection, à deux exceptions près :

<!-- paragraph -->

- les variables de sélection pilotées par les données qui sont définies à l'aide de l'option [namedclickSelects/showSelectedvariables](Ch06-other.html#data-driven-selectors) .
<!-- comment -->
- les variables de sélection qui ont beaucoup de valeurs (elles sont lentes à afficher).

<!-- paragraph -->

Ces valeurs par défaut devraient convenir à la grande majorité des animints.
<!-- comment -->
Pour ceux qui sont intéressés par un exemple de la façon dont la fonction `selectize` veuillez consulter l'exemple de l'option [PredictedPeaks dans le code source de animint2](https://github.com/tdhock/animint2/blob/master/tests/testthat/test-renderer2-PredictedPeaks.R) .

<!-- paragraph -->

## Résumé du chapitre et exercices {#Ch06-exercises}

<!-- paragraph -->

Ce chapitre a expliqué plusieurs options de personnalisation des animints au niveau de l'observation, du geom, du graphique et du global.

<!-- paragraph -->

Exercices :

<!-- paragraph -->

- Créez d'autres versions de `viz.chunk.vars` avec différentes valeurs de `chunk_vars` pour les `geom_point` et `geom_segment`.
<!-- comment -->
Comment le choix des `chunk_vars` affecte-t-il l'apparence de la visualisation ?
<!-- comment -->
L'espace disque ?
<!-- comment -->
Le temps de chargement ?

<!-- paragraph -->

Suivant, [Chapitre 7](Ch07-limitations.html) explique les limites de l'implémentation actuelle de animint2.

<!-- paragraph -->


