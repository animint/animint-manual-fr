---
title: Limitations
layout: default
output: bookdown::html_chapter
---


Traduction de l'[anglais](https://github.com/tdhock/animint-book/)
[Ch07-limitations](https://raw.githubusercontent.com/tdhock/animint-book/master/Ch07-limitations.Rmd)

<!-- paragraph -->

# Chapitre 7, Limites de animint2 et solutions de contournement

<!-- paragraph -->

```{r}
#| echo: false
knitr::opts_chunk$set(fig.path="Ch07-figures/")
```

<!-- paragraph -->

Ce chapitre explique plusieurs limites connues d'`animint2` pour certaines tâches de visualisation de données interactives.
<!-- comment -->
Il explique également quelques solutions de contournement que vous pouvez utiliser dans ces situations.
<!-- comment -->
Après avoir lu ce chapitre, vous saurez comment

<!-- paragraph -->

- Utiliser une variable normalisée lorsque différents sous-ensembles `showSelected` ont des valeurs très différentes pour une variable que vous souhaitez afficher.
<!-- comment -->
- Calculer les statistiques pour chaque sous-ensemble `showSelected` plutôt que de s'appuyer sur les fonctions `stat_*` de `ggplot2`.
<!-- comment -->
- Ajouter des données une par une à un ensemble de variables à sélection multiple, plutôt que d'utiliser un pinceau de sélection rectangulaire.
<!-- comment -->
- Évitez d'utiliser `vjust` et les étiquettes comportant plusieurs lignes dans `geom_text`.
<!-- comment -->
- Ordonner les graphiques sur la page.
<!-- comment -->
- Évitez d'utiliser des options `theme` non supportées.
<!-- comment -->
- Utiliser des facettes avec plusieurs variables par axe.
<!-- comment -->
- Utiliser le package de serveur web `shiny` pour modifier de manière interactive la cartographie esthétique d'un `animint`, ou pour effectuer des calculs basés sur des valeurs sélectionnées.

<!-- paragraph -->

Si vous avez une idée pour améliorer `animint2` afin qu'il surmonte l'une de ces limitations, les développeurs d'`animint2` seraient plus qu'heureux d'accepter votre [Pull Request](https://github.com/tdhock/animint2/compare) .

<!-- paragraph -->

## Utiliser des variables normalisées pour travailler avec des échelles standardisées {#normalized-variables}

<!-- paragraph -->

Nous implémentons les axes et les légendes de la même manière que `ggplot2`, en les calculant une fois lorsque le graphique est généré pour la première fois.
<!-- comment -->
Par conséquent, les axes et les légendes de chaque graphique animint ne sont pas interactifs.
<!-- comment -->
Pour la plupart des [visualisations de données animées](Ch03-showSelected.html#animation-time) les axes fixes permettent de comprendre facilement comment les données changent en même temps que la variable `time`.

<!-- paragraph -->

Dans certaines situations, il serait utile d'avoir des axes qui se mettent à jour de manière interactive.
<!-- comment -->
Un exemple est lorsque différents sous-ensembles `showSelected` ont des valeurs très différentes pour les variables qui sont affichées avec un axe ou une légende.
<!-- comment -->
Dans ce cas, il serait utile d'avoir des axes interactifs qui se mettent à jour et changent en même temps que les données.
<!-- comment -->
Nous disposons d'une prise en charge expérimentale pour cela, voir [la mise à jour axestest](https://github.com/tdhock/animint2/blob/master/tests/testthat/test-renderer4-update-axes-multiple-ss.R) pour plus de détails.

<!-- paragraph -->

## Calcul des statistiques pour chaque sous-ensemble showSeleted (ou réalisation d'un sous-ensemble). {#stats}

<!-- paragraph -->

`Animint` ne prend pas en charge les statistiques `ggplot2` avec `showSelected`.
<!-- comment -->
Par exemple, considérons le ggplot à facettes ci-dessous.

<!-- paragraph -->

```{r}
set.seed(1)
library(data.table)
random.counts <- data.table(
  letter = c(replicate(4, LETTERS[1:5])),
  count = c(replicate(4, rbinom(5, 50, 0.5))),
  stack = rep(rep(1:2, each = 5), 2),
  facet = rep(1:2, each = 10))
library(animint2)
ggstat <- ggplot() +
  theme_bw()+
  theme(panel.margin=grid::unit(0, "lines"))+
  geom_bar(
      aes(letter, count, fill = stack),
      showSelected="facet",
    data = random.counts,
    stat = "identity",
    position="stack"
  )
ggstat+facet_grid(facet ~ .)
```

<!-- paragraph -->

Utiliser `showSelected` au lieu des facettes ne donne pas le résultat escompté.

<!-- paragraph -->

```{r Ch07-viz-stat}
animint(
  plot = ggstat,
  time = list(variable = "facet", ms = 1000),
  duration = list(facet = 1000))
```

<!-- paragraph -->

Une solution de contournement consiste à calculer ce que vous voulez afficher, puis à utiliser `position=identity`.

<!-- paragraph -->

```{r}
random.cumsums <- random.counts[, list(
  cumsum=cumsum(count),
  count=count,
  stack=stack),
  by=.(letter, facet)]
ggidentity <- ggplot() +
  theme_bw()+
  theme(panel.margin=grid::unit(0, "lines"))+
  geom_segment(aes(
    x=letter, xend=letter,
    y=cumsum, yend=cumsum-count,
    color=stack),
    showSelected="facet",
    data = random.cumsums,
    size=10,
    stat = "identity",
    position="identity")
ggidentity+facet_grid(facet ~ .)
```

<!-- paragraph -->

Notez que nous avons utilisé `geom_segment` au lieu de `geom_bar` mais leur apparence est similaire.

<!-- paragraph -->

```{r Ch07-viz-identity}
animint(
  plot = ggidentity,
  time = list(variable = "facet", ms = 1000),
  duration = list(facet = 1000))
```

<!-- paragraph -->

## Ajouter des valeurs à un ensemble de sélection multiple, une à la fois {#multiple-selection}

<!-- paragraph -->

`Animint` ne prend pas en charge une brosse rectangulaire ou un lasso pour définir interactivement un ensemble de valeurs prises en charge.
<!-- comment -->
Au lieu de cela, `animint` prend en charge la sélection multiple en ajoutant des valeurs une par une à l'ensemble de sélection multiple.
<!-- comment -->
Utilisez l'option [selector.types](Ch04-clickSelects.html#selector-types-option) pour déclarer une variable de sélection multiple.

<!-- paragraph -->

## Ajuster y au lieu d'utiliser vjust {#vjust}

<!-- paragraph -->

Pour l'alignement horizontal du texte, animint prend en charge l'utilisation de `hjust` dans R avec les valeurs les plus courantes : 0 pour l'alignement à gauche, 0,5 pour l'alignement au milieu et 1 pour l'alignement à droite.
<!-- comment -->
`Animint2` traduit ces trois valeurs `hjust` en propriété `text-anchor` dans la visualisation de données générée.

<!-- paragraph -->

Cependant, `animint` ne prend pas en charge l'alignement vertical du texte à l'aide de `vjust` dans R, car il n'y a pas de propriété qui puisse être utilisée pour l'alignement vertical du texte en SVG.

<!-- paragraph -->

```{r}
line.df <- data.frame(just=c(0, 0.5, 1))
text.df <- expand.grid(
  vjust=line.df$just,
  hjust=line.df$just)
gg.lines <- ggplot()+
  theme_bw()+
  geom_vline(aes(xintercept=just), data=line.df, color="grey")+
  geom_hline(aes(yintercept=just), data=line.df, color="grey")
gg.vjust <- gg.lines+
  geom_text(aes(
    hjust, vjust, label="qwerty", hjust=hjust, vjust=vjust),
    size=10,
    data=text.df)
gg.vjust+ggtitle("R graphics devices respect aes(vjust)")
```

<!-- paragraph -->

Notez comment `hjust` et `vjust` sont respectés dans le ggplot statique ci-dessus.
<!-- comment -->
En revanche, considérons l'`animint` ci-dessous.
<!-- comment -->
Le graphique de gauche devrait être le même que le ggplot ci-dessus, mais il y a des différences évidentes en termes de placement vertical des éléments de texte.

<!-- paragraph -->

```{r Ch07-viz-just}
(viz.just <- animint(
  vjust=gg.vjust+
    ggtitle("animint does not support aes(vjust)"),
  workaround=gg.lines+
    ggtitle("workaround: no aes(vjust), add to y")+
    geom_text(aes(
      hjust, vjust + (0.5-vjust)*0.03 - 0.01,
      label="qwerty", hjust=hjust),
      data=text.df)))
```

<!-- paragraph -->

La solution de contournement dans `animint2` est illustrée dans le panneau de droite ci-dessus.
<!-- comment -->
Vous pouvez ajuster les valeurs de la position verticale `y` des éléments de texte pour lesquels vous auriez utilisé la `vjust`.

<!-- paragraph -->

Il est possible d'implémenter une prise en charge de `vjust` dans `animint2`, mais nous n'avons pas encore eu le temps d'y travailler.
<!-- comment -->
Si vous souhaitez l'implémenter, nous serions plus qu'heureux d'accepter une Pull Request.
<!-- comment -->
Nous avons déjà une [issue expliquant comment l'implémenter.](https://github.com/tdhock/animint/issues/148) .

<!-- paragraph -->

## Ordonner les graphiques sur la page {#order-plots}

<!-- paragraph -->

Actuellement, la seule façon d'organiser une visualisation des données multiplot est d'utiliser l'ordre des ggplots dans la liste `animint` `viz`.
<!-- comment -->
Les graphiques apparaîtront sur la page web dans le même ordre que celui dans lequel ils apparaissent dans la liste `animint` `viz`.
<!-- comment -->
Par exemple, comparez la visualisation de données ci-dessous avec la visualisation de données de la section précédente.

<!-- paragraph -->

```{r Ch07-viz-order}
animint(
  first=viz.just$workaround,
  second=viz.just$vjust)
```

<!-- paragraph -->

Notez que l'ordre des graphiques est inversé par rapport à la visualisation de données de la section précédente.
<!-- comment -->
La principale limite de cette méthode de mise en page des graphiques est que seul l'ordre peut être contrôlé.
<!-- comment -->
Par exemple, en fonction de la largeur de l'élément de la page web dans lequel la visualisation de données ci-dessus est affichée, le deuxième graphique apparaîtra soit sous le premier graphique, soit à sa droite.

<!-- paragraph -->

Si vous avez une idée pour une meilleure façon de définir la mise en page des graphiques dans une animint, [merci de nous en faire part](https://github.com/tdhock/animint2/issues) !

<!-- paragraph -->

## Éviter les sauts de ligne dans les étiquettes de texte {#line-breaks}

<!-- paragraph -->

Lors de l'affichage d'un ggplot à l'aide des périphériques graphiques R habituels, l'utilisation d'un saut de ligne ou d'une nouvelle ligne `\n` dans une étiquette `geom_text` entraîne l'apparition de plusieurs lignes de texte sur le graphique.

<!-- paragraph -->

```{r}
gg.return <- ggplot()+
  geom_text(aes(
    hjust, vjust, label=sprintf("x=%.1f\ny=%.1f", hjust, vjust)),
    size=3,
    data=text.df)
gg.return
```

<!-- paragraph -->

Cependant, `animint2` ne prend en charge que le tracé de la première ligne de texte.

<!-- paragraph -->

```{r Ch07-viz-return}
animint(gg.return)
```

<!-- paragraph -->

Il serait bien de pouvoir gérer plusieurs lignes dans les étiquettes `geom_text`, mais nous n'avons pas encore eu le temps de l'implémenter.
<!-- comment -->
Cependant, nous avons [une issue](https://github.com/tdhock/animint/issues/149) et nous serions prêts à accepter une Pull Request qui implémente cela.

<!-- paragraph -->

En attendant, la solution de contournement consiste à utiliser un seul `geom_text` pour chaque ligne de texte que vous souhaitez afficher :

<!-- paragraph -->

```{r Ch07-viz-two-lines}
gg.two.lines <- ggplot()+
  geom_text(aes(
    hjust, vjust, label=sprintf("x=%.1f", hjust)),
    size=3,
    data=text.df)+
  geom_text(aes(
    hjust, vjust-0.05, label=sprintf("y=%.1f", vjust)),
    size=3,
    data=text.df)
gg.two.lines
animint(gg.two.lines)
```

<!-- paragraph -->

## Éviter certaines options du thème ggplot {#theme-options}

<!-- paragraph -->

L'un des objectifs d'`animint2` est de prendre en charge [toutes les options de thème](http://docs.ggplot2.org/current/theme.html), mais nous n'avons pas encore eu le temps de toutes les implémenter.
<!-- comment -->
S'il y a une option de thème que vous utilisez et qu'`animint2` ne prend pas encore en charge, alors envoyez-nous une Pull Request.
<!-- comment -->
La liste suivante documente toutes les options `theme` déjà prises en charge par `animint2`.

<!-- paragraph -->

- `panel.margin` désigne la distance entre les panneaux, et est utilisé dans l' [idiome des facettes d'économie d'espace](Ch99-appendix.html#space-saving-facets) pour éliminer la distance entre les panneaux.
<!-- comment -->
- `panel.grid.major` est utilisé pour dessiner les lignes de la grille qui sont désignées par l'argument `breaks` à l'échelle.
<!-- comment -->
- `panel.grid.minor` est utilisé pour dessiner les lignes de la grille entre les lignes principales de la grille.
<!-- comment -->
- `panel.background` est utilisé pour le `<rect>` en arrière-plan de chaque panneau.
<!-- comment -->
- `panel.border` est utilisé pour la bordure `<rect>` de chaque panneau (sur l'arrière-plan `<rect>`).
<!-- comment -->
- `legend.position="none"` fonctionne pour cacher toutes les légendes, mais aucune des autres positions de légende n'est prise en charge (les légendes apparaissent toujours à droite du graphique).

<!-- paragraph -->

Les options de thème suivantes peuvent être définies par `element_blank` pour masquer les axes.

<!-- paragraph -->

- `axis.title`, `axis.title.x`, `axis.title.y` désignent le titre de l'axe.
<!-- comment -->
- `axis.ticks`, `axis.ticks.x`, `axis.ticks.y` désignent les tics de l'axe.
<!-- comment -->
- `axis.line`, `axis.line.x`, `axis.line.y` désignent la ligne d'axe.
<!-- comment -->
- `axis.text`, `axis.text.x`, `axis.text.y` désignent l'étiquette de texte de l'axe, et prennent en charge les arguments `angle` et `hjust` de `element_text`.

<!-- paragraph -->

## Facettes avec plusieurs variables par axe {#facet-strips}

<!-- paragraph -->

`Animint2` prend en charge `facet_grid` pour créer des visualisations de données à plusieurs panneaux, mais ne prend en charge que de manière limitée les variables multiples par axe.
<!-- comment -->
Par exemple, le ggplot ci-dessous utilise deux variables pour créer des facettes verticales, ce qui se traduit par deux étiquettes de bande lorsqu'elles sont générées avec `ggplot2`.

<!-- paragraph -->

```{r}
data(intreg)
signals.df <- transform(
  intreg$signals,
  person=sub("[.].*", "p", signal),
  chromosome=sub(".*[.]", "c", signal))
two.strips <- ggplot()+
  theme_animint(height=600)+
  facet_grid(person + chromosome ~ ., scales="free")+
  geom_point(aes(base/1e6, logratio), data=signals.df)
two.strips+ggtitle("two strip labels on the right")
```

<!-- paragraph -->

En comparaison, `animint2` affiche le même `ggplot` ci-dessous en n'utilisant qu'une seule étiquette de bande.

<!-- paragraph -->

```{r Ch07-viz-strips}
animint(two.strips+ggtitle("only one strip label"))
```

<!-- paragraph -->

Il serait intéressant de prendre en charge plusieurs étiquettes de bande par axe, mais nous n'avons pas encore eu le temps de l'implémenter.
<!-- comment -->
Si vous souhaitez implémenter cette fonctionnalité, nous serions heureux d'accepter votre Pull Request.

<!-- paragraph -->

## Définition interactive de mappings `aes()` à l'aide de shiny {#shiny-aes}

<!-- paragraph -->

Normalement, les mappings `aes()` sont définis une fois dans le code R, et ne peuvent pas être modifiés après avoir affiché un `animint`.
<!-- comment -->
Une façon de surmonter cette limitation est de définir des entrées `shiny` qui sont utilisées comme `aes()` d'`animint`, comme dans l'exemple suivant.

<!-- paragraph -->

```{r, eval=FALSE}
shiny::runApp(system.file(
  "examples", "shiny-WorldBank", package="animint2"))
```

<!-- paragraph -->

## Calcul interactif {#shiny-computation}

<!-- paragraph -->

Une autre limitation est qu'`animint2` ne peut afficher que des données qui peuvent être calculées et stockées dans un tableau de données avant la création de la visualisation.
<!-- comment -->
Cela signifie qu'animint n'est pas approprié lorsqu'il y a plus de sous-ensembles de données à tracer qu'il n'est possible d'en calculer.
<!-- comment -->
Dans ce cas, il serait préférable d'utiliser shiny.

<!-- paragraph -->

## Résumé du chapitre et exercices {#Ch07-exercises}

<!-- paragraph -->

Nous avons discuté des limitations de l'implémentation actuelle de `animint2` et implémenté plusieurs solutions de contournement.

<!-- paragraph -->

Exercices :

<!-- paragraph -->

- Réalisez un ggplot à facettes avec `stat_bin` qui ne fonctionnera pas avec `animint2` lorsque la variable facette est utilisée en tant que variable `showSelected`.
<!-- comment -->
Calculez vous-même le statut pour chaque facette, et utilisez `stat_identity` pour que cela fonctionne avec `animint2`.
<!-- comment -->
- Faites un ggplot qui s'affiche bien en utilisant `facet_grid(. ~ var, scales="free")` mais ne s'affiche pas correctement avec `showSelected=var`.
<!-- comment -->
<!-- comment -->
Pour résoudre le problème, calculez une version normalisée de `var` et utilisez la pour la variable `showSelected`.

<!-- paragraph -->

Dans le [chapitre 8](Ch08-WorldBank-facets.html), nous vous expliquerons comment créer une visualisation multi-panneaux des données de la Banque mondiale.

<!-- paragraph -->


