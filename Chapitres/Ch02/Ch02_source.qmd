---
title: Grammar of graphics
layout: default
output: bookdown::html_chapter
---

# Chapter 2, data visualization using the grammar of graphics {#chapter-2}

```{r setup, echo=FALSE}
knitr::opts_chunk$set(fig.path="Ch02-figures/")
```

This chapter explains the grammar of graphics, which is a powerful model for describing a large class of data visualizations.
<!-- comment -->
After reading this chapter, you will be able to

<!-- comment -->

* State the advantages of the grammar of graphics relative to previous plotting systems
<!-- comment -->
* Install the animint2 R package 
<!-- comment -->
* Translate plot sketches into ggplot code in R
<!-- comment -->
* Render ggplots on web pages using animint2
<!-- comment -->
* Create multi-layer ggplots
<!-- comment -->
* Create multi-panel ggplots

<!-- comment -->

## History and purpose of the grammar of graphics {#history}

<!-- comment -->

Most computer systems for data analysis provide functions for creating plots to visualize patterns in data.
<!-- comment -->
The oldest systems provide very general functions for drawing basic plot components such as lines and points (e.g. the `graphics` and `grid` packages in R).
<!-- comment -->
If you use one of these general systems, then it is your job to put the components together to form a meaningful, interpretable plot.
<!-- comment -->
The advantage of general systems is that they impose few limitations on what kinds of plots can be created.
<!-- comment -->
The disadvantage is that general systems typically do not provide functions for automating common plotting tasks (axes, panels, legends).

<!-- comment -->

To overcome the disadvantages of these general plotting systems, charting packages such as `lattice` were developed ([Sarkar, 2008](http://lmdvr.r-forge.r-project.org/figures/figures.html)).
<!-- comment -->
Such packages have several pre-defined chart types, and provide a dedicated function for creating each chart type.
<!-- comment -->
For example, `lattice` provides the `bwplot` function for making box and whisker plots.
<!-- comment -->
The advantage of such systems is that they make it much easier to create entire plots, including a legend and panels.
<!-- comment -->
The disadvantage is the set of pre-defined chart types, which means that it is not easy to create more complex graphics.

<!-- comment -->

Newer plotting systems based on the grammar of graphics are situated between these two extremes.
<!-- comment -->
Wilkinson proposed the grammar of graphics in order to describe and create a large class of plots ([Wilkinson, 2005](http://www.springer.com/us/book/9780387245447?wt_mc=GoogleBooks.GoogleBooks.3.EN&token=gbgen#otherversion=9780387286952)).
<!-- comment -->
Wickham later implemented several ideas from the grammar of graphics in the `ggplot2` R package ([Wickham, 2009](https://www.amazon.com/dp/0387981403/ref=cm_sw_su_dp?tag=ggplot2-20)).
<!-- comment -->
The `ggplot2` package has several advantages with respect to previous plotting systems.

<!-- comment -->

* Like general plotting systems, and unlike `lattice`, `ggplot2` imposes few limitations on the types of plots that can be created (there are no pre-defined chart types).
<!-- comment -->
* Unlike general plotting systems, and like `lattice`, `ggplot2` makes it easy to include common plot elements such as axes, panels, and legends.
<!-- comment -->
* Since `ggplot2` is based on the grammar of graphics, an explicit mapping of data variables to visual properties is required. Later in this chapter, we will explain how this mapping allows sketches of plot ideas to be directly translated into R code.

<!-- comment -->

Finally, all of the previously discussed plotting systems are intended for creating *static* graphics, which can be viewed equally well on a computer screen or on paper.
<!-- comment -->
However, the main topic of this manual is `animint2`, an R package for *interactive* graphics.
<!-- comment -->
In contrast to static graphics, interactive graphics are best viewed on a computer with a mouse and keyboard that can be used to interact with the plot.

<!-- comment -->

Since many concepts from static graphics are also useful in interactive graphics, the `animint2` package is implemented as an extension/fork of `ggplot2`.
<!-- comment -->
In this chapter we will introduce the main features of `ggplot2` which will also be useful for interactive plot design in later chapters.

<!-- comment -->

In 2013, we created the animint package, which depends on the ggplot2 package.
<!-- comment -->
However during 2014-2017, the ggplot2 package introduced many changes that were incompatible with the interactive grammar of animint.
<!-- comment -->
Therefore in 2018 we created the animint2 package which copies/forks the relevant parts of the ggplot2 package.
<!-- comment -->
Now animint2 can be used without having ggplot2 installed.
<!-- comment -->
In fact, it is recommended to use animint2 without attaching (via library) ggplot2.
<!-- comment -->
However it is fine to use animint2 along with packages that import/load ggplot2.
<!-- comment -->
For an example, see [Chapter 16](Ch16-change-point.html), which uses the penaltyLearning package (which imports ggplot2).

<!-- comment -->

## Installing and attaching animint2 {#installing}

<!-- comment -->

To install the most recent release of `animint2` from CRAN,

<!-- comment -->

```{r installCRAN}
if(!requireNamespace("animint2"))install.packages("animint2")
```

<!-- comment -->

To install an even more recent development version of `animint2` from GitHub,

<!-- comment -->

```{r installGitHub}
if(!requireNamespace("animint2")){
  if(!requireNamespace("remotes"))install.packages("remotes")
  remotes::install_github("tdhock/animint2")
}
```

<!-- comment -->

Once you have installed animint2, you can load and attach all of its exported functions via:

<!-- comment -->

```{r attach}
library(animint2)
```

<!-- comment -->

## Translating plot sketches into ggplots {#sketching}

<!-- comment -->

This section explains how to translate a plot sketch into R code.
<!-- comment -->
We use a data set from the World Bank as an example, and we begin by loading and looking at a subset these data.

<!-- comment -->

```{r data}
data(WorldBank, package="animint2")
WorldBank$Region <- sub(" (all income levels)", "", WorldBank$region, fixed=TRUE)
head(WorldBank)
tail(WorldBank)
dim(WorldBank)
```

<!-- comment -->

The `WorldBank` data set consist of measures such as fertility rate and life expectancy for each country over the period 1960-2010.
<!-- comment -->
The code above prints the first and last few rows, and the dimension of the data table (`r nrow(WorldBank)` rows and `r ncol(WorldBank)` columns).

<!-- comment -->

Suppose that we are interested to see if there is any relationship between life expectancy and fertility rate.
<!-- comment -->
We could fix one year, then use those two data variables in a scatterplot.
<!-- comment -->
Consider the figure below which sketches the main components of that data visualization.

<!-- comment -->

<!-- comment -->

![World Bank scatterplot](Ch02-viz-scatter.png)

<!-- comment -->

The sketch above shows life expectancy on the horizontal (x) axis, fertility rate on the vertical (y) axis, and a legend for the region.
<!-- comment -->
These elements of the sketch can be directly translated into R code using the following method.
<!-- comment -->
First, we need to construct a data table that has one row for every country in 1975, and columns named `life.expectancy`, `fertility.rate`, and `region`.
<!-- comment -->
The `WorldBank` data already has these columns, so all we need to do is consider the subset for the year 1975:

<!-- comment -->

```{r head}
WorldBank1975 <- subset(WorldBank, year==1975)
head(WorldBank1975)
```

<!-- comment -->

The code above prints the data for 1975, which clearly has the appropriate columns, and one row for each country.
<!-- comment -->
The next step is to use the notes in the sketch to code a ggplot with a corresponding `aes` or aesthetic mapping of data variables to visual properties:

<!-- comment -->

```{r scatter}
scatter <- ggplot()+
  geom_point(
    mapping=aes(x=life.expectancy, y=fertility.rate, color=Region),
    data=WorldBank1975)
scatter
```

<!-- comment -->

The `aes` function is called with names for visual properties (`x`, `y`, `color`) and values for the corresponding data variables (`life.expectancy`, `fertility.rate`, `region`).
<!-- comment -->
This mapping is applied to the variables in the `WorldBank1975` data table, in order to create the visual properties of the `geom_point`.
<!-- comment -->
The ggplot was
saved as the `scatter` object, which when printed on the R command line shows the plot on a graphics device.
<!-- comment -->
Note that we automatically have a `region` color legend.

<!-- comment -->

## Rendering ggplots on web pages using animint {#rendering-with-animint}

<!-- comment -->

This section explains how the `animint2` package can be used to render ggplots on web pages.
<!-- comment -->
The ggplot from the previous section can be rendered with animint2, by using the `animint` function.

<!-- comment -->

```{r Ch02-scatter}
animint(scatter)
```

<!-- comment -->

If, when you run the code above, the animint does not render in your web browser for some reason (for example if you see a blank web page), then please consult our [wiki FAQ](https://github.com/tdhock/animint2/wiki/FAQ#web-browser-on-local-indexhtml-file-is-blank) which will help you find a solution.
<!-- comment -->
Internally, the `animint` function creates a list of class animint, and then R runs the `print.animint` function via the [S3 object system](http://adv-r.had.co.nz/OO-essentials.html#s3).
<!-- comment -->
The `animint2` package implements a compiler that takes the list as input, and outputs a web page with a data visualization. 
<!-- comment -->
The compiler is the `animint2dir` function, which compiles the animint `scatter.viz` list to a directory of data and code files that can be rendered in a web browser.
<!-- comment -->
It is activated automatically by the `print.animint` function.

<!-- comment -->

When viewed in a web browser, the animint plot should look mostly the same as static versions produced by standard R graphics devices.
<!-- comment -->
One difference is that the region legend is interactive: clicking a legend entry will hide or show the points of that color.

<!-- comment -->

**Exercise**: try changing the `aes` mapping of the ggplot, and then making a new animint.
<!-- comment -->
Quantitative variables like `population` are best shown using the `x`/`y` axes or point `size`.
<!-- comment -->
Qualitative variables like `lending` are best shown using point `color` or `fill`.

<!-- comment -->

## Multi-layer data visualization (multiple geoms) {#multi-layer}

<!-- comment -->

Multi-layer data visualization is useful when you want to display several different geoms or data sets in the same plot.
<!-- comment -->
For example, consider the following sketch which adds a `geom_path` to the previous data visualization.

<!-- comment -->

![multi-layer WorldBank data viz](Ch02-two-layer-viz.png)

<!-- comment -->

Note how the sketch above includes two different geoms (point and path).
<!-- comment -->
The two geoms share a common definition of the `x`, `y`, and `color` aesthetics, but have different data sets.
<!-- comment -->
Below we translate this sketch into R code.

<!-- comment -->

```{r Ch02-two-layer-viz}
WorldBankBefore1975 <- subset(WorldBank, 1970 <= year & year <= 1975)
two.layers <- scatter+
  geom_path(aes(
    x=life.expectancy, 
    y=fertility.rate, 
    color=Region,
    group=country),
    data=WorldBankBefore1975)
(viz.two.layers <- animint(two.layers))
```

<!-- comment -->

Note that we save the return value of the `animint` function to the `viz.two.layers` object (which is also printed due to the parentheses).
<!-- comment -->
In this manual we will often use variable names that start with `viz` to denote animint data visualization objects, which are in fact lists of ggplots and options.

<!-- comment -->

The plot above shows a data visualization with 2 geoms/layers: 

<!-- comment -->

* the `geom_point` shows the life expectancy, fertility rate, and region of all countries in 1975.
<!-- comment -->
* the `geom_path` shows the same variables for the previous 5 years.

<!-- comment -->

The addition of the `geom_path` shows how the countries changed over time.
<!-- comment -->
In particular, it shows that most countries moved to the right and down, meaning higher life expectancy and lower fertility rate.
<!-- comment -->
However, there are some exceptions.
<!-- comment -->
For example, the two East Asian countries in the bottom left suffered a decrease in life expectancy over this period.
<!-- comment -->
And there are some countries which showed an increased fertility rate.

<!-- comment -->

**Exercise**: try changing the `region` legend to an `income` legend.
<!-- comment -->
Hint: you need to use the same `aes(color=income)` specification for all geoms.
<!-- comment -->
You may want to use `scale_color_manual` with a sequential color palette, see `RColorBrewer::display.brewer.all(type="seq")` and [read the appendix for more details](Ch99-appendix.html#manual-color-legends).
  
<!-- comment -->

Can we add the names of the countries to the data viz?
<!-- comment -->
Below, we add another layer with a text label for each country's name.

<!-- comment -->

```{r Ch02-three-layer-viz}
three.layers <- two.layers+
  geom_text(aes(
    x=life.expectancy, 
    y=fertility.rate, 
    color=Region,
    label=country),
    data=WorldBank1975)
animint(three.layers)
```

<!-- comment -->

This data viz is not so easy to read, since there are so many overlapping text labels.
<!-- comment -->
The interactive region legend helps a little, by allowing the user to hide data from selected regions.
<!-- comment -->
However, it would be even better if the user could show and hide the text for individual countries.
<!-- comment -->
That type of interaction can be achieved using the showSelected and clickSelects aesthetics which we explain in Chapters 3-4.

<!-- comment -->

For now, we move on to discuss a major strength of animint: data visualization with multiple linked plots.

<!-- comment -->

## Multi-plot data visualization {#multi-plot}

<!-- comment -->

Multi-plot data visualization is useful when you want to show some related data sets using more than one aesthetic mapping.
<!-- comment -->
In interactive data visualization, one plot is often used to display a summary, and another plot is used to display details.
<!-- comment -->
For example, consider a data visualization with two plots: a time series with World Bank data from 1960-2010 (summary), and a scatterplot with data from 1975 (details).
<!-- comment -->
We sketch the time series plot below.

<!-- comment -->

![WorldBank data viz with two plots](Ch02-viz-two-plots.png)

<!-- comment -->

Note how the sketch above can be directly translated into the R code below. 
<!-- comment -->
For simplicity, we first down-sample the data set to every five years (some web browsers like chromium are not able to display 10,000+ data points at once),

<!-- comment -->

```{r}
WorldBankSome <- subset(WorldBank, year %% 5 == 0)
dim(WorldBankSome)
table(WorldBankSome$year)
```

<!-- comment -->

The table above shows that there are 214 rows for each of the years in the data set.
<!-- comment -->
Next we copy the existing viz list (`viz.two.layers`), then we assign a ggplot to a new element named `timeSeries`. 

 <!-- comment -->

```{r vizTwoPlots}
viz.two.plots <- viz.two.layers
viz.two.plots$timeSeries <- ggplot()+
  geom_line(aes(
    x=year, 
    y=fertility.rate, 
    color=Region, 
    group=country),
    data=WorldBankSome)
```

<!-- comment -->

That results in a named list of two elements (both elements are ggplots with class `gganimint`).

<!-- comment -->

```{r summaryTwo}
summary(viz.two.plots)
```

<!-- comment -->

This data visualization list can be printed/rendered by typing its name.
<!-- comment -->
Since the list contains two ggplots, `animint2` renders the data viz as two linked plots.

<!-- comment -->

<!-- comment -->

```{r Ch02-viz-two-plots}
viz.two.plots
```

<!-- comment -->

The data visualization above contains two ggplots, which each map different data variables to the horizontal `x` axis.
<!-- comment -->
The time series uses `aes(x=year)`, and shows a summary of fertility rate values over all years.
<!-- comment -->
The scatterplot uses `aes(x=life.expectancy)`, and shows details of the relationship between fertility rate and life expectancy during 1975.

<!-- comment -->

**Try** clicking a legend entry in either the scatterplot or the time series above.
<!-- comment -->
You should see the data and legends in both plots update simultaneously.
<!-- comment -->
Since `aes(color=Region)` was specified in both plots, animint creates a single shared selector variable called `Region`.
<!-- comment -->
Clicking either legend has the effect of updating the set of selected regions, and so animint updates the legends and data in both plots accordingly.
<!-- comment -->
This is the main mechanism that animint uses to create interactive data visualizations with linked plots, and will be discussed in more detail in the next two chapters.

<!-- comment -->

**Exercise**: use animint to create a data viz with three plots, by creating a list with three ggplots.
<!-- comment -->
For example, you could add a time series of another data variable such as `life.expectancy` or`population`.

<!-- comment -->

Note that both ggplots map the fertility rate variable to the y axis.
<!-- comment -->
However, since they are separate plots, the ranges of their y axes are computed separately.
<!-- comment -->
That means that even when the two plots are rendered side-by-side, the two y axis are not exactly aligned.
<!-- comment -->
That is a problem since it would make it easier to decode the data visualization if each unit of vertical space was used to show the same amount of fertility rate.
<!-- comment -->
To achieve that effect, we use facets in the next section.

<!-- comment -->

## Multi-panel data visualization (facets) {#multi-panel}

<!-- comment -->

Panels or facets are sub-plots that show related data visualizations.
<!-- comment -->
One of the main strengths of ggplots is that different kinds of multi-panel plots are relatively easy to create.
<!-- comment -->
Multi-panel data visualization is useful for two different purposes:

<!-- comment -->

* You want to align the axes of several related plots containing different geoms. This facilitates comparison between several different geoms, and is a technique that is also useful for interactive data visualization.
* You want to divide the data from one geom into several panels. This facilitates comparison between data subsets, and is less useful for interactive data visualization (interactivity can often be used instead, to achieve the same effect of comparing data subsets).

<!-- comment -->

### Different geoms in each panel (aligned axes) {#aligned-axes}
  
<!-- comment -->

We begin by explaining the how facets are useful to align the axes of related plots.
<!-- comment -->
Consider the sketch below which contains a plot with two panels.

<!-- comment -->

![World Bank aligned plot](Ch02-viz-aligned.png)

<!-- comment -->

Note that the two panels plot different geoms using a panel-specific aesthetic mapping.
<!-- comment -->
The point and path in the left panel have `x=life.expectancy`, and the line in the right panel has `x=year`.
<!-- comment -->
Also note that we specified `facet=x.var`, so we need to add a variable called `x.var` to each of the three data sets.
<!-- comment -->
We translate this sketch to the R code below.

<!-- comment -->

<!-- comment -->

```{r Ch02-viz-aligned}
add.x.var <- function(df, x.var){
  data.frame(df, x.var=factor(x.var, c("life expectancy", "year")))
}
(viz.aligned <- animint(
  scatter=ggplot()+
    theme_bw()+
    theme_animint(width=600)+
    geom_point(aes(
      x=life.expectancy, y=fertility.rate, color=Region),
      data=add.x.var(WorldBank1975, "life expectancy"))+
    geom_path(aes(
      x=life.expectancy, y=fertility.rate, color=Region,
      group=country),
      data=add.x.var(WorldBankBefore1975, "life expectancy"))+
    geom_line(aes(
      x=year, y=fertility.rate, color=Region, group=country),
      data=add.x.var(WorldBankSome, "year"))+
    xlab("")+
    facet_grid(. ~ x.var, scales="free")))
```

<!-- comment -->

The data visualization above contains a single ggplot with two panels and three layers.
<!-- comment -->
The left panel shows the `geom_point` and `geom_path`, and the right panel shows the `geom_line`.
<!-- comment -->
The panels have a shared axis for fertility rate, which ensures that the lines in the time series panel can be directly compared with the points and paths in the scatterplot panel.

<!-- comment -->

Note that we used the `add.x.var` function to add a `x.var` variable to each data set, and then we used that variable in `facet_grid(scales="free")`.
<!-- comment -->
We call this the [addColumn then facet idiom](Ch99-appendix.html#addColumn-then-facet), which is generally useful for creating a multi-panel data visualization with aligned axes.
<!-- comment -->
In particular, if we wanted to change the order of the panels in the data visualization, we would only need to edit the order of the factor levels in the definition of `add.x.var`.

<!-- comment -->

Also note that `theme_bw` means to use black panel borders and white panel backgrounds, and `panel.margin=0` means to use no space between panels.
<!-- comment -->
Eliminating the space between panels means that more space will be used for the panels, which serves to emphasize the data.
<!-- comment -->
We call this the [Space saving facets idiom](Ch99-appendix.html#space-saving-facets), which is generally useful in any ggplot with facets.

<!-- comment -->

In the data viz above, the text labels overlap a bit, which can be fixed by either (exercise for the reader)

<!-- comment -->

* using `breaks` argument of `scale_x_continuous()`
<!-- comment -->
* reducing text size with `theme()` and `element_text()`
<!-- comment -->
* increasing plot width using `theme_animint()`, see [Chapter 6](Ch06-other.html#plot-height-width) for more info.

<!-- comment -->

### Same geoms in each panel (compare data subsets) {#compare-data-subsets}

<!-- comment -->

The second reason for using plots with multiple panels in a data visualization is to compare subsets of observations.
<!-- comment -->
This facilitates comparison between data subsets, and can be used in at least two different situations:

<!-- comment -->

* One geom's data set has too many observations to display informatively in one panel.
<!-- comment -->
* You want to compare different subsets of data that is plotted for one geom.

<!-- comment -->

For example, consider the sketch below.

<!-- comment -->

![World Bank panels plot](Ch02-viz-panels.png)

<!-- comment -->

Note that the three panels plot the same two geoms (point and path).
<!-- comment -->
Since `facet=show.year`, and there are three panels shown, we will need to create data tables which have three values for the `show.year` variable.
<!-- comment -->
The `geom_point` has data for just 3 years, and the `geom_path` has data for 15 years (but 3 values of `show.year`).
<!-- comment -->
The code below creates these two data sets for three years of the WorldBank data set.

<!-- comment -->

<!-- comment -->

```{r}
show.point.list <- list()
show.path.list <- list()
for(show.year in c(1975, 1985, 1995)){
  show.point.list[[paste(show.year)]] <- data.frame(
    show.year, subset(WorldBank, year==show.year))
  show.path.list[[paste(show.year)]] <- data.frame(
    show.year, subset(WorldBank, show.year - 5 <= year & year <= show.year))
}
show.point <- do.call(rbind, show.point.list)
show.path <- do.call(rbind, show.path.list)
```

<!-- comment -->

We used a for loop over three values of `show.year`, the variable which we will use later in `facet_grid`.
<!-- comment -->
For each value of `show.year`, we store a data subset as a named element of a list.
<!-- comment -->
After the for loop, we use `do.call` with `rbind` to combine the data subsets.
<!-- comment -->
This is an example of the [list of data tables idiom](Ch99-appendix.html#list-of-data-tables), which is generally useful for interactive data visualization.

<!-- comment -->

Below, we facet on the `show.year` variable to create a data visualization with three panels.

<!-- comment -->

<!-- comment -->

```{r Ch02-viz-panels}
animint(
  scatter=ggplot()+
    geom_point(aes(
      x=life.expectancy, y=fertility.rate, color=Region),
      data=show.point)+
    geom_path(aes(
      x=life.expectancy, y=fertility.rate, color=Region,
      group=country),
      data=show.path)+
    facet_grid(. ~ show.year)+
    theme_bw())
```

<!-- comment -->

The data visualization above contains a single ggplot with three panels.
<!-- comment -->
It shows more of the WorldBank data set than the previous visualizations which showed only the data from 1975.
<!-- comment -->
However, it still only shows a relatively small data subset.
<!-- comment -->
You may be tempted to try using a panel to display every year (not just 1975, 1985, and 1995).
<!-- comment -->
However, beware that this type of multi-panel data visualization is especially useful if there are only a few data subsets.
<!-- comment -->
With more than about 10 panels, it becomes difficult to see all the data at once, and thus difficult to make meaningful comparisons.

<!-- comment -->

Instead of showing all of the data at once, we can instead create an animated data visualization that shows the viewer different data subsets over time.
<!-- comment -->
In the [next chapter](Ch03-showSelected.html), we will show how the new `showSelected` keyword can be used to achieve animation, and reveal more details of this data set.

<!-- comment -->

## Chapter summary and exercises {#exercises}

<!-- comment -->

This chapter presented the basics of static data visualization using ggplot2.
<!-- comment -->
We showed how animint can be used to render a list of ggplots in a web browser.
<!-- comment -->
We explained two features of ggplot2 that make it ideal for data visualization: multi-layer and multi-panel graphics.

<!-- comment -->

Exercises:

<!-- comment -->

* What are the three main advantages of `ggplot2` relative to previous plotting systems such as `grid` and `lattice`?
<!-- comment -->
* What is the purpose of multi-layer graphics?
<!-- comment -->
* What are the two different reasons for creating multi-panel graphics? Which of these two types is useful with interactivity?
<!-- comment -->
* Let us define "A < B" to mean that "one B can contain several A." Which of the following statements is true?
<!-- comment -->
	* ggplot < panel
  <!-- comment -->
	* panel < ggplot
  <!-- comment -->
	* ggplot < animint
  <!-- comment -->
	* animint < ggplot
  <!-- comment -->
	* layer < panel
  <!-- comment -->
	* panel < layer
  <!-- comment -->
	* layer < ggplot
  <!-- comment -->
	* ggplot < layer
  <!-- comment -->
	
* In the `viz.aligned` facets, why is it important to use the `scales="free"` argument?
<!-- comment -->
* In `viz.aligned` we showed a ggplot with a scatterplot panel on the left and a time series panel on the right. Make another version of the data visualization with the time series panel on the left and the scatterplot panel on the right.
<!-- comment -->
* In `viz.aligned` the scatterplot displays fertility rate and life expectancy, but the time series displays only fertility rate. Make another version of the data visualization that shows both time series. Hint: use both horizontal and vertical panels in `facet_grid`.
<!-- comment -->
* Use `aes(size=population)` in the scatterplot to show the population of each country. Hint: `scale_size_animint(pixel.range=c(5, 10)` means that circles with a radius of 5/10 pixels should be used represent the minimum/maximum population.
<!-- comment -->
* Create a multi-panel data visualization that shows each year of the `WorldBank` data set in a separate panel. What are the limitations of using static graphics to visualize these data?
<!-- comment -->
* Create `viz.aligned` using a plotting system that is not based on the grammar of graphics. For example, you can use functions from the `graphics` package in R (`plot`, `points`, `lines`, etc), or matplotlib in Python. What are some advantages of ggplot2 and animint?

<!-- comment -->

Next, [Chapter 3](Ch03-showSelected.html) explains the `showSelected` keyword, which indicates a variable to use for subsetting the data before plotting.
