---
title: Grammar of graphics
layout: default
output: bookdown::html_chapter
---

# Chapter 2, data visualization using the grammar of graphics {#chapter-2}

```{r setup, echo=FALSE}
knitr::opts_chunk$set(fig.path="Ch02-figures/")
```

Ce chapitre explique la grammaire des graphiques, qui est un modèle puissant pour décrire une grande classe de visualisations de données.
Après avoir lu ce chapitre, vous serez en mesure de
* Citer les avantages de la grammaire des graphiques par rapport aux systèmes précédents pour la visualisation de données
* Installer le package R `animint2 `
* Traduire les esquisses de graphique en code ggplot dans R
* Afficher des ggplots sur des pages web en utilisant `animint2`
* Créer des ggplots avec multiples couches
* Créer des ggplots avec multiples panneaux

## Historique et objectif de la grammaire des graphiques {#history}

La plupart des systèmes informatiques d'analyse de données proposent des fonctions permettant de créer des graphiques afin de visualiser les tendances dans les données.
Les systèmes les plus anciens proposent des fonctions très générales permettant de tracer les éléments de base d'un graphique, tels que des lignes et des points (par exemple, les packages `graphics`  et `grid`  dans R).
Si vous utilisez l'un de ces systèmes généraux, c'est à vous d'assembler les composants pour former un graphique significatif et interprétable.
L'avantage des systèmes généraux est qu'ils imposent peu de limites aux types de graphiques qui peuvent être créés.
L'inconvénient est que les systèmes généraux ne fournissent généralement pas de fonctions permettant d'automatiser les tâches courantes (axes, panneaux, légendes).

Pour remédier aux inconvénients de ces systèmes de tracé généraux, des packages de visualisation tels que `lattice`  ont été développés ( [Sarkar, 2008](http://lmdvr.r-forge.r-project.org/figures/figures.html) ).
Ces packages disposent de plusieurs types de graphiques prédéfinis et fournissent une fonction dédiée à la création de chaque type de graphique.
 Par exemple, `lattice` fournit la fonction `bwplot`  pour créer des diagrammes en boîte et des boîtes à moustaches.
L'avantage de ces systèmes est qu'ils facilitent grandement la création de certains graphiques en entiers, y compris une légende et des panneaux.
L'inconvénient est que l'ensemble des types de graphiques sont prédéfinis, ce qui fait qu'il n'est pas facile de créer des graphiques plus complexes.

Les nouveaux systèmes basés sur la grammaire des graphiques se situent entre ces deux extrêmes.
Wilkinson a proposé la grammaire des graphiques afin de décrire et de créer une grande classe de graphiques ([Wilkinson, 2005](http://www.springer.com/us/book/9780387245447?wt_mc=GoogleBooks.GoogleBooks.3.EN&token=gbgen#otherversion=9780387286952)).
Wickham a implémenté plus tard plusieurs idées de la grammaire des graphiques dans le package R `ggplot2` ([Wickham, 2009](https://www.amazon.com/dp/0387981403/ref=cm_sw_su_dp?tag=ggplot2-20)).
Le package `ggplot2` présente plusieurs avantages par rapport aux systèmes de tracé précédents.

* Comme les systèmes généraux, et contrairement à `lattice`, `ggplot2` impose peu de limites aux types de graphiques qui peuvent être créés (il n'y a pas de types de graphiques prédéfinis).
* Contrairement aux systèmes généraux, et à l'instar de `lattice`, `ggplot2` permet d'inclure facilement des éléments de graphique courants tels que des axes, des panneaux et des légendes.
* Puisque `ggplot2` est basé sur la grammaire des graphiques, il est nécessaire de mapper explicitement les variables de données aux propriétés visuelles. Plus loin dans ce chapitre, nous expliquerons comment ce mappage permet la création d'esquisses qui peuvent être directement traduites en code R.

Enfin, tous les systèmes évoqués précédemment sont destinés à la création de graphiques statiques, qui peuvent être visualisés aussi bien sur un écran d'ordinateur que sur du papier.
Cependant, le sujet principal de ce manuel est `animint2`, un package R pour les graphiques interactifs.
Contrairement aux graphiques statiques, les graphiques interactifs sont mieux visualisés sur un ordinateur équipé d'une souris et d'un clavier permettant d'interagir avec le graphique.

Étant donné que de nombreux concepts des graphiques statiques sont également utiles dans les graphiques interactifs, le package `animint2`  est implémenté en tant qu'extension/fork du package `ggplot2`.
Dans ce chapitre, nous présenterons les principales caractéristiques de `ggplot2`  qui seront également utiles pour la conception de graphiques interactifs dans les chapitres suivants.

En 2013, nous avons créé le package `animint`, qui dépend du package `ggplot2`.
Cependant, au cours de la période 2014-2017, le package `ggplot2` a introduit de nombreux changements qui étaient incompatibles avec la grammaire interactive du package `animint`.
Par conséquent, en 2018, nous avons créé le package `animint2` qui copie/fork les parties pertinentes du package `ggplot2`.
Maintenant, `animint2` peut être utilisé sans que `ggplot2` soit installé.
En fait, il est conseillé d'utiliser `animint2` sans attacher (avec `library`) `ggplot2`.
Cependant, il est possible d'utiliser `animint2` avec des packages qui importent/chargent `ggplot2`.
Pour un exemple, voir [Chapitre 16](Ch16-change-point.html) qui utilise le package `penaltyLearning` (qui importe `ggplot2`).

## Installer et attacher animint2 {#installing}

Pour installer la version la plus récente de `animint2`  à partir du CRAN,

```{r installCRAN}
if(!requireNamespace("animint2"))install.packages("animint2")
```

Pour installer une version de développement encore plus récente de `animint2`  depuis GitHub,

```{r installGitHub}
if(!requireNamespace("animint2")){
  if(!requireNamespace("remotes"))install.packages("remotes")
  remotes::install_github("tdhock/animint2")
}
```

Une fois que vous avez installé `animint2`, vous pouvez charger et attacher toutes ses fonctions exportées via :

```{r attach}
library(animint2)
```

## Traduire des esquisses en ggplots {#sketching}

Cette section explique comment traduire une esquisse de graphique en code R.
Nous utilisons un ensemble de données de la Banque mondiale comme exemple, et nous commençons par charger et examiner un sous-ensemble de ces données.

```{r data}
data(BanqueMondiale, package="animint2fr")
BanqueMondiale$Region <- sub(
  " (all income levels)", "", BanqueMondiale$région, fixed=TRUE)
subset(BanqueMondiale, pays=="Canada" & année==2010)
dim(BanqueMondiale)
```

Le jeu de données `BanqueMondiale`  comprend des mesures telles que le taux de fertilité et l'espérance de vie pour chaque pays sur la période 1960-2010.
Le code ci-dessus imprime les premières et dernières lignes, ainsi que la dimension (lignes `r nrow(BanqueMondiale)` et colonnes `r ncol(BanqueMondiale)`) du tableau de données.

Supposons que nous voulions voir s'il existe une relation entre l'espérance de vie et le taux de fertilité.
 Nous pourrions fixer une année, puis utiliser ces deux variables de données dans un nuage de points.
La figure ci-dessous esquisse les principaux éléments de cette visualisation de données.

![World Bank scatterplot](Ch02-viz-scatter.png)

L'esquisse ci-dessus montre l'espérance de vie sur l'axe horizontal (x), le taux de fertilité sur l'axe vertical (y) et une légende pour la région.
Ces éléments de l'esquisse peuvent être directement traduits en code R à l'aide de la méthode suivante.
Tout d'abord, nous devons construire un tableau de données comportant une ligne pour chaque pays en 1975, et des colonnes nommées `espérance.de.vie`, `taux.de.fertilité`, et `région`.
Les données `BanqueMondiale` possèdent déjà ces colonnes, il suffit donc de considérer le sous-ensemble pour l'année 1975 :

```{r head}
BanqueMondiale1975 <- subset(BanqueMondiale, année==1975)
subset(BanqueMondiale1975, pays=="Canada")
```

Le code ci-dessus imprime les données pour 1975, qui ont clairement les colonnes appropriées, et une ligne pour chaque pays
L'étape suivante consiste à utiliser les notes de l'esquisse pour coder un ggplot avec une fonction correspondante de `aes`  ou un mappage `aes` des variables de données aux propriétés visuelles :

```{r scatter}
scatter <- ggplot()+
  geom_point(
    mapping=aes(x=espérance.de.vie, y=taux.de.fertilité, color=région),
    data=BanqueMondiale1975)
scatter
```

La fonction `aes`  est appelée avec les noms des propriétés visuelles ( `x` , `y` , `color` ) et les valeurs des variables de données correspondantes ( `espérance.de.vie` , `taux.de.fertilité` , `région` )
Ce mappage est appliqué aux variables du tableau de données `BanqueMondiale1975`, afin de créer les propriétés de visualisation du `geom_point` .
Le ggplot a été sauvegardé en tant qu'objet `scatter`  qui, lorsqu'il est imprimé sur la ligne de commande R, affiche le graphique sur un périphérique graphique.
Notez que nous avons automatiquement une légende `région` en couleur.

## Afficher des ggplots sur des pages web à l'aide d'animint {#rendering-with-animint}

Cette section explique comment `animint2`  peut être utilisé pour afficher des ggplots sur des pages web.
Le ggplot de la section précédente peut être affiché avec `animint2`, en utilisant la fonction `animint`

```{r Ch02-scatter}
animint(scatter)
```

Si, lorsque vous exécutez le code ci-dessus, l'animint ne s'affiche pas dans votre navigateur web pour une raison quelconque (par exemple si vous voyez une page web vierge), veuillez consulter notre section [FAQ wiki](https://github.com/tdhock/animint2/wiki/FAQ#web-browser-on-local-indexhtml-file-is-blank)  qui vous aidera à trouver une solution.
En arrière plan, la fonction `animint`  crée une liste avec classes animint, puis R exécute la fonction `print.animint`  via la fonction [système d'objets S3](http://adv-r.had.co.nz/OO-essentials.html#s3).
Le package `animint2`  implémente un compilateur qui prend la liste en entrée et qui produit une page web avec une visualisation de données. 
Le compilateur est la fonction `animint2dir`  qui compile la liste animint `scatter.viz`  en un répertoire de fichiers de données et de code qui peuvent être affichés dans un navigateur web.
Elle est activée automatiquement par la fonction `print.animint`.

Lorsqu'il est visualisé dans un navigateur web, le graphiquee animint devrait être pratiquement identique aux versions statiques produites par les périphériques graphiques R standard.
Une différence est que la légende de la région est interactive : en cliquant sur une entrée de la légende, les points de cette couleur sont cachés ou affichés.

**Exercice**: essayez de modifier la valeur de `aes` du ggplot, puis de créer une nouvelle visualisation.
Les variables quantitatives comme `population`  sont mieux représentées à l'aide des axes `x` / `y`  ou des points `size`.
Les variables qualitatives comme `lending`  sont mieux représentées en utilisant le point `color`  ou `fill`.

## Visualisation de données multicouches (plusieurs geoms) {#multi-layer}

La visualisation de données multicouches est utile lorsque vous souhaitez afficher plusieurs geoms ou ensembles de données différents dans le même graphique.
Par exemple, considérons l'esquisse suivante qui ajoute une couche de `geom_path` à la visualisation de données précédente.

![multi-layer WorldBank data viz](Ch02-two-layer-viz.png)

Notez que l'esquisse ci-dessus comprend deux geoms différents (point et path).
Les deux geoms partagent une définition commune des éléments `x` , `y` , et de l'`aes` `color`, mais avec des ensembles de données différents.
Nous traduisons ci-dessous cette esquisse en code R.

```{r Ch02-two-layer-viz}
BanqueMondialeAvant1975 <- subset(
  BanqueMondiale, 1970 <= année & année <= 1975)
deux.couches <- scatter+
  geom_path(aes(
    x=espérance.de.vie, 
    y=taux.de.fertilité, 
    color=région,
    group=pays),
    data=BanqueMondialeAvant1975)
(vis.deux.couches <- animint(deux.couches))
```

Notez que nous sauvegardons la valeur de retour de la fonction `animint`  dans l'objet `vis.deux.couches`  (qui est également imprimé en raison des parenthèses).
Dans ce manuel, nous utiliserons souvent des noms de variables commençant par `vis`  pour désigner les objets de classe `animint`, qui sont en fait des listes de ggplots et d'options.

Le graphique ci-dessus montre une visualisation de données avec 2 geoms/couches : 

* le `geom_point`  montre l'espérance de vie, le taux de fertilité et la région de tous les pays en 1975.
* le `geom_path`  montre les mêmes variables pour les 5 années précédentes.

L'ajout de `geom_path`  montre comment les pays ont changé au fil du temps.
En particulier, il montre que la plupart des pays se sont déplacés vers la droite et vers le bas, ce qui signifie une espérance de vie plus élevée et un taux de fertilité plus faible.
Il y a cependant quelques exceptions.
Par exemple, les deux pays d'Asie de l'Est situés en bas à gauche ont vu leur espérance de vie diminuer au cours de cette période.
Par ailleurs, certains pays ont vu leur taux de fertilité augmenter.

**Exercice**: essayez de changer la légende `région`  par une légende `revenu`.
Indice : vous devez utiliser la même spécification `aes(color=revenu)`  pour tous les geoms.
Vous pouvez utiliser `scale_color_manual` avec une palette de couleurs séquentielle, voir `RColorBrewer::display.brewer.all(type="seq")` et [lire l'annexe pour plus de détails](Ch99-appendix.html#manual-color-legends).
  

Pouvons-nous ajouter les noms des pays à la visualisation de données ?
Ci-dessous, nous ajoutons une autre couche avec une étiquette de texte pour le nom de chaque pays.

```{r Ch02-three-layer-viz}
trois.couches <- deux.couches+
  geom_text(aes(
    x=espérance.de.vie, 
    y=taux.de.fertilité, 
    color=région,
    label=pays),
    data=BanqueMondiale1975)
animint(trois.couches)
```

Cette visualisation n'est pas très facile à lire, car il y a beaucoup d'étiquettes de texte qui se chevauchent.
La légende interactive des régions aide un peu, en permettant à l'utilisateur de masquer les données des régions sélectionnées.
Cependant, ce serait encore mieux si l'utilisateur pouvait afficher et masquer le texte pour les pays individuellement.
Ce type d'interaction peut être réalisé en utilisant les mots-clés `showSelected` et `clickSelects` que nous expliquons dans les chapitres 3-4.

Pour l'instant, nous passons à une des grandes forces d'`animint` : la visualisation de données à l'aide de plusieurs graphiques interconnectés.

## Visualisation multi-graphiques de données{#multi-plot}

La visualisation de données multi-graphiques est utile lorsque vous souhaitez présenter des ensembles de données liés en utilisant plus d'un mappage `aes`.
Dans la visualisation de données interactive, un graphique est souvent utilisé pour afficher un sommaire et un autre pour afficher les détails.
Prenons l'exemple d'une visualisation comportant deux graphiques : une série temporelle avec les données de la Banque mondiale de 1960 à 2010 (sommaire) et un nuage de points avec les données de 1975 (détails).
Nous esquissons ci-dessous le graphique des séries temporelles.

![WorldBank data viz with two plots](Ch02-viz-two-plots.png)

Notez que l'esquisse ci-dessus peut être directement traduite dans le code R ci-dessous. 
Pour plus de simplicité, nous commençons par réduire l'échantillonnage des données à tous les cinq ans (certains explorateurs web comme Chromium ne sont pas en mesure d'afficher plus de 10 000 points de données en une seule fois),

```{r}
BanqueMondialeSome <- subset(BanqueMondiale, année %% 5 == 0)
dim(BanqueMondialeSome)
table(BanqueMondialeSome$année)
```

Le tableau de contingence ci-dessus montre qu'il y a 214 lignes pour chacune des années de l'ensemble de données.
Ensuite, nous copions la liste vis existante ( `vis.deux.couches` ), puis nous assignons un ggplot à un nouvel élément nommé `timeSeries`. 

 
```{r vizTwoPlots}
vis.deux.graphes <- vis.deux.couches
vis.deux.graphes$timeSeries <- ggplot()+
  geom_line(aes(
    x=année, 
    y=taux.de.fertilité, 
    color=région, 
    group=pays),
    data=BanqueMondialeSome)
```

Il en résulte une liste nommée de deux éléments (les deux éléments sont des ggplots de classe `gganimint`).

```{r summaryTwo}
summary(vis.deux.graphes)
```

Cette liste de visualisation de données peut être imprimée ou affichée en tapant son nom.
Puisque la liste contient deux ggplots, `animint2`  affiche la visualisation de données sous la forme de deux graphiques liés.

```{r Ch02-viz-two-plots}
vis.deux.graphes
```

La visualisation de données ci-dessus contient deux ggplots, qui mappent chacun différentes variables de données sur le plan horizontal `x`.
La série temporelle utilise `aes(x=année)` et montre un résumé des valeurs du taux de fertilité pour toutes les années.
Le nuage de points utilise `aes(x=espérance.de.vie)` et montre les détails de la relation entre le taux de fertilité et l'espérance de vie en 1975.

**Essayez** de cliquer sur une entrée de légende dans le nuage de points ou dans la série temporelle ci-dessus.
Vous devriez voir les données et les légendes des deux graphiques se mettre à jour simultanément.
Etant donné que `aes(color=région)` a été spécifié dans les deux graphiques, `animint` crée une seule variable de sélection partagée appelée `région`.
Cliquer sur l'une des légendes a pour effet de mettre à jour l'ensemble des régions sélectionnées, et `animint` met donc à jour les légendes et les données dans les deux graphiques en conséquence.
Il s'agit du mécanisme principal utilisé par `animint` pour créer des visualisations de données interactives avec des graphiques liés, et il sera discuté plus en détail dans les deux prochains chapitres.

**Exercice**: utilisez `animint` pour créer une visualisation de données avec trois graphiques, en créant une liste avec trois ggplots.
Par exemple, vous pouvez ajouter une série temporelle d'une autre variable de données telle que `espérance.de.vie` ou `population`.

Notez que les deux ggplots mappent la variable taux.de.fertilité sur l'axe y.
Cependant, comme il s'agit de deux graphiques distincts, les plages de leurs axes y sont calculées séparément.
Cela signifie que même lorsque les deux graphiques sont affichés côte à côte, les deux axes y ne sont pas exactement alignés.
C'est un problème car il serait plus facile de décoder la visualisation des données si chaque unité d'espace vertical était utilisée pour montrer la même quantité de taux de fertilité.
Pour obtenir cet effet, nous utilisons les facettes dans la section suivante.

## Visualisation de données multi-panneaux (facettes) {#multi-panel}

Les panneaux ou facettes sont des sous-graphiques qui présentent des visualisations de données connectées.
L'un des principaux atouts de ggplots est qu'il est relativement facile de créer différents types de graphiques multi-panneaux.
La visualisation de données multi-panneaux est utile à deux fins différentes :

* Vous souhaitez aligner les axes de plusieurs graphiques connexes contenant différents geoms. Cela facilite la comparaison entre plusieurs geoms différents et c'est une technique qui est également utile pour la visualisation interactive des données.
* Vous souhaitez diviser les données d'un geom en plusieurs panneaux. Cette technique facilite la comparaison entre des sous-ensembles de données et est moins utile pour la visualisation interactive de données (l'interactivité peut souvent être utilisée à la place, pour obtenir le même effet de comparaison de sous-ensembles de données).

### Différents geom dans chaque panneau (axes alignés) {#aligned-axes}
  

Nous commençons par expliquer comment les facettes sont utiles pour aligner les axes de graphiques apparentés.
Considérons l'esquisse ci-dessous qui contient un graphique avec deux panneaux.

![World Bank aligned plot](Ch02-viz-aligned.png)

Notez que les deux panneaux tracent des geoms différents à l'aide d'une cartographie esthétique spécifique au panneau.
Le point et le path dans le panneau de gauche ont `x=espérance.de.vie` et la ligne du panneau de droite a `x=année` .
Notez également que nous avons spécifié `facet=x.var` nous devons donc ajouter une variable appelée `x.var` à chacun des trois ensembles de données.
Nous traduisons cette esquisse en code R ci-dessous.

```{r Ch02-viz-aligned}
add.x.var <- function(df, x.var){
  data.frame(df, x.var=factor(x.var, c("espérance de vie", "année")))
}
(vis.aligné <- animint(
  scatter=ggplot()+
    theme_bw()+
    theme_animint(width=600)+
    geom_point(aes(
      x=espérance.de.vie, y=taux.de.fertilité, color=région),
      data=add.x.var(BanqueMondiale1975, "espérance de vie"))+
    geom_path(aes(
      x=espérance.de.vie, y=taux.de.fertilité, color=région,
      group=pays),
      data=add.x.var(BanqueMondialeAvant1975, "espérance de vie"))+
    geom_line(aes(
      x=year, y=taux.de.fertilité, color=région, group=pays),
      data=add.x.var(BanqueMondialeSome, "année"))+
    xlab("")+
    facet_grid(. ~ x.var, scales="free")))
```

La visualisation de données ci-dessus contient un seul ggplot avec deux panneaux et trois couches.
Le panneau de gauche montre les `geom_point` et `geom_path` et le panneau de droite montre les `geom_line`.
Les panneaux ont un axe commun pour le taux de fertilité, ce qui permet de comparer directement les lignes du panneau des séries temporelles avec les points et les chemins du panneau du nuage de points.

Il est à noter que nous avons utilisé la méthode `add.x.var` pour ajouter une variable `x.var` à chaque ensemble de données, puis nous avons utilisé cette variable dans la fonction `facet_grid(scales="free")`.
Nous appelons cela l'[idiome addColumn then facet](Ch99-appendix.html#addColumn-then-facet) qui est généralement utile pour créer une visualisation de données à plusieurs panneaux avec des axes alignés.
En particulier, si nous voulions changer l'ordre des panneaux dans la visualisation, il nous suffirait de modifier l'ordre des niveaux de facteurs dans la définition de `add.x.var` .

Notez également que `theme_bw`  signifie qu'il faut utiliser des bordures de panneaux noires et des fonds de panneaux blancs, et que `panel.margin=0`  signifie qu'il n'y a pas d'espace entre les panneaux.
En éliminant l'espace entre les panneaux, on utilise plus d'espace pour les panneaux, ce qui permet d'accentuer les données.
C'est ce que nous appelons l'[idiome facettes économes en espace](Ch99-appendix.html#space-saving-facets) qui est généralement utile dans tout ggplot avec des facettes.

Dans la visualisation ci-dessus, les étiquettes de texte se chevauchent un peu, ce qui peut être corrigé par l'une des méthodes suivantes (exercice pour le lecteur).

* en utilisant l'argument `breaks` de `scale_x_continuous()`
* en réduisant la taille du texte avec `theme()`  et `element_text()`
* en augmentant la largeur du graphique à l'aide de `theme_animint()` voir [Chapitre 6](Ch06-other.html#plot-height-width)  pour plus d'informations.

### Mêmes geoms dans chaque panneau (réalisation de sous-ensembles de données) {#compare-data-subsets}

La deuxième raison d'utiliser des graphes avec plusieurs panneaux dans une visualisation de données est de comparer des sous-ensembles d'observations.
Cela facilite la comparaison entre les sous-ensembles de données et peut être utilisé dans au moins deux situations différentes :

* L'ensemble de données d'un geom comporte trop d'observations pour être affiché de manière informative dans un seul panneau.
* Vous souhaitez comparer différents sous-ensembles de données tracées pour un geom

Prenons l'exemple de l'esquisse ci-dessous.

![World Bank panels plot](Ch02-viz-panels.png)

Notez que les trois panneaux tracent les deux mêmes geoms (point et path).
Puisque `facet=show.année` et qu'il y a trois panneaux, nous devrons créer des tableaux de données qui auront trois valeurs pour la variable `show.année`.
Le `geom_point`  ne contient des données que pour 3 ans, et le tableau `geom_path` a des données pour 15 ans (mais 3 valeurs de `show.année`).
Le code ci-dessous crée ces deux ensembles de données pour trois années de l'ensemble de données de la Banque mondiale.

```{r}
show.point.list <- list()
show.path.list <- list()
for(show.année in c(1975, 1985, 1995)){
  show.point.list[[paste(show.année)]] <- data.frame(
    show.année, subset(
      BanqueMondiale, année==show.année))
  show.path.list[[paste(show.année)]] <- data.frame(
    show.année, subset(
      BanqueMondiale, show.année - 5 <= année & année <= show.année))
}
show.point <- do.call(rbind, show.point.list)
show.path <- do.call(rbind, show.path.list)
```

Nous avons utilisé une boucle for sur trois valeurs de `show.année` la variable que nous utiliserons plus tard dans `facet_grid`.
Pour chaque valeur de `show.année` nous stockons un sous-ensemble de données sous la forme d'un élément nommé d'une liste.
Après la boucle for, nous utilisons `do.call`  avec `rbind`  pour combiner les sous-ensembles de données.
Il s'agit d'un exemple de la méthode [liste detableau de données idiome](Ch99-appendix.html#list-of-data-tables) qui est généralement utile pour la visualisation interactive des données.

Ci-dessous, nous appliquons les facettes sur la variable `show.année`  pour créer une visualisation de données avec trois panneaux.

```{r Ch02-viz-panels}
animint(
  scatter=ggplot()+
    geom_point(aes(
      x=espérance.de.vie, y=taux.de.fertilité, color=région),
      data=show.point)+
    geom_path(aes(
      x=espérance.de.vie, y=taux.de.fertilité, color=région,
      group=pays),
      data=show.path)+
    facet_grid(. ~ show.année)+
    theme_bw())
```

La visualisation de données ci-dessus contient un seul ggplot avec trois panneaux
Elle montre une plus grande partie de l'ensemble des données de la Banque mondiale que les visualisations précédentes qui ne montraient que les données de 1975.
Cependant, elle ne montre qu'un sous-ensemble de données relativement restreint.
Vous pourriez être tenté d'utiliser un panneau pour afficher chaque année (pas seulement 1975, 1985 et 1995).
Sachez toutefois que ce type de visualisation de données à plusieurs panneaux n'est utile que s'il n'y a que quelques sous-ensembles de données.
Au-delà d'une dizaine de panneaux, il devient difficile de voir toutes les données en même temps, et donc de faire des comparaisons significatives.

Au lieu de montrer toutes les données en même temps, nous pouvons créer une visualisation de données animée qui montre à l'observateur différents sous-ensembles de données au fil du temps.
Dans le [chapitre suivant](Ch03-showSelected.html) nous montrerons comment le nouveau mot-clé `showSelected`  peut être utilisé pour réaliser une animation, et nous révélerons plus de détails sur cet ensemble de données.

## Résumé du chapitre et exercices {#exercises}

Ce chapitre a présenté les bases de la visualisation de données statiques avec `ggplot2`.
Nous avons montré comment animint peut être utilisé pour afficher une liste de ggplots dans un navigateur web.
Nous avons expliqué deux caractéristiques de `ggplot2` qui le rendent idéal pour la visualisation de données : les graphiques avec multiples couches et multi-panneaux.

Exercices :

* Quels sont les trois principaux avantages de `ggplot2`  par rapport aux systèmes antérieurs tels que `grid`  et `lattice` ?
* Quel est l'objectif des graphiques multi-couches ?
* Quelles sont les deux raisons différentes de créer des graphiques à panneaux multiples ? Lequel de ces deux types est utile pour l'interactivité ?
* Définissons "A < B" comme signifiant qu'"un B peut contenir plusieurs A". Laquelle des affirmations suivantes est vraie ?
	* ggplot < panel
  	* panel < ggplot
  	* ggplot < animint
  	* animint < ggplot
  	* layer < panel
  	* panel < layer
  	* layer < ggplot
  	* ggplot < layer
  	
* Dans les facettes `vis.alignée`, pourquoi est-il important d'utiliser l'argument `scales="free"` ?
* Dans `vis.alignée`  nous avons montré un ggplot avec un panneau de nuage de points à gauche et un panneau de séries temporelles à droite. Réalisez une autre version de la visualisation de données avec le panneau des séries temporelles à gauche et le panneau du nuage de points à droite.
* Dans `vis.alignée`  le nuage de points affiche le taux de fécondité et l'espérance de vie, mais la série chronologique n'affiche que le taux de fertilité. Réalisez une autre version de la visualisation de données qui montre les deux séries temporelles. Indice : utilisez les panneaux horizontaux et verticaux dans `facet_grid`.
* Utilisez `aes(size=population)` dans le nuage de points pour indiquer la population de chaque pays. Indice : `scale_size_animint(pixel.range=c(5, 10))`  signifie que des cercles d'un rayon de 5/10 pixels doivent être utilisés pour représenter la population minimale/maximale.
* Créez une visualisation de données à plusieurs panneaux qui montre chaque année de la `BanqueMondiale`  dans un panneau séparé. Quelles sont les limites de l'utilisation de graphiques statiques pour visualiser ces données ?
* Créez un `vis.alignée`  en utilisant un système de tracé qui n'est pas basé sur la grammaire des graphiques. Par exemple, vous pouvez utiliser les fonctions du package `graphics` dans R (`plot` ,`points` ,`lines` etc.), ou `matplotlib` en Python. Quels sont les avantages de `ggplot2` et `animint` ?

Ensuite, [Chapitre 3](Ch03-showSelected.html)  explique le mot-clé `showSelected`  qui indique une variable à utiliser pour le sous-ensemble des données avant le tracé.
